)abbrev domain STACK Stack
++ Author: Michael Monagan and Stephen Watt
++ Date Created: June 86 and July 87
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:

++ Linked List implementation of a Stack
--% Dequeue and Heap data types

Stack(S : SetCategory) : StackAggregate S with
    stack : List S -> %
      ++ stack([x, y, ..., z]) creates a stack with first (top)
      ++ element x, second element y, ..., and last element z.
  == add
    Rep := Reference List S
    s = t == deref s = deref t
    parts s == deref s
    map(f : S -> S, s : %) == ref map(f, deref s)$List(S)
    map!(f : S -> S, s : %) ==
        setref(s, map!(f, deref s)$List(S))
        s
    copy s == ref copy deref s
    # s == #deref s
    pop! (s : %) : S ==
        empty? s => error "empty stack"
        e := first deref s
        setref(s, rest deref s)
        e
    extract! (s : %) : S == pop! s
    top (s : %) : S ==
        empty? s => error "empty stack"
        first deref s
    inspect s == top s
    push!(e, s) == (setref(s, cons(e, deref s));e)
    insert!(e : S, s : %) : % == (push!(e, s);s)
    empty() == ref nil()$List(S)
    empty? s == null deref s
    construct s == ref s
    stack s == construct s
    hashUpdate!(st, s) == hashUpdate!(st, deref s)

)abbrev domain ASTACK ArrayStack
++ Author: Michael Monagan and Stephen Watt
++ Date Created: June 86 and July 87
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:

++ A stack represented as a flexible array.
--% Dequeue and Heap data types

ArrayStack(S : SetCategory) : StackAggregate(S) with
    arrayStack : List S -> %
      ++ arrayStack([x, y, ..., z]) creates an array stack with first (top)
      ++ element x, second element y, ..., and last element z.
  == add
    Rep := IndexedFlexibleArray(S, 0)

    -- system operations
    # s == _#(s)$Rep
    s = t == s =$Rep t
    copy s == copy(s)$Rep
    coerce(d) : OutputForm ==
        empty? d => empty()$(List S) ::OutputForm
        n := #d
        [(d.(n - i))::OutputForm for i in 1..n]::OutputForm

    -- stack operations
    empty? s == empty?(s)$Rep
    extract! s == pop! s
    inspect(s) == top(s)
    insert!(e, s) == (push!(e, s);s)
    parts(s) == reverse(parts(s)$Rep)
    push!(e, s) == (concat!(s, e); e)
    pop! s ==
        if empty? s then error "empty stack"
        m := maxIndex s
        r := s.m
        delete!(s, m)
        r
    top s == if empty? s then error "empty stack" else s.maxIndex(s)
    construct(l) == construct(reverse(l))$Rep
    arrayStack l == construct(l)
    empty() == empty()$Rep
    map(f, s) == map(f, s)$Rep
    map!(f, s) == map!(f, s)$Rep
    hashUpdate!(hs, s) == hashUpdate!(hs, s)$Rep

)abbrev domain QUEUE Queue
++ Author: Michael Monagan and Stephen Watt
++ Date Created: June 86 and July 87
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:

Queue(S : SetCategory) : QueueAggregate S with
    queue : List S -> %
      ++ queue([x, y, ..., z]) creates a queue with first (top)
      ++ element x, second element y, ..., and last (bottom) element z.
  == add
    Rep := Record(front: List S, rear: List S)

    queue q == construct q
    construct q == [q, []]
    empty() == [[], []]
    empty? q == empty? q.front and empty? q.rear
    copy q == [copy q.front, copy q.rear]
    map(f, q) ==
        [map(f, q.front), reverse! map!(f, reverse q.rear)]
    map!(f, q) ==
        q.front := map!(f, q.front)
        q.rear := reverse! map!(f, reverse! q.rear)
        q
    # q == # q.front + # q.rear
    parts q == append(q.front, reverse q.rear)
    hashUpdate!(st, q) == hashUpdate!(st, parts q)

    -- QueueAggregate's exclusive operations
    enqueue!(e, q) ==
        q.rear := cons(e, q.rear)
        e

    dequeue! q ==
        if empty? q.front then
            empty? q.rear => error "empty queue"
            q.front := reverse! q.rear
            q.rear := []
        e := first q.front
        q.front := rest q.front
        e

    front q ==
        empty? q.front =>
            empty? q.rear => error "empty queue"
            last q.rear
        first q.front

    back q ==
        empty? q.rear =>
            empty? q.front => error "empty queue"
            last q.front
        first q.rear

    -- BagAggregate's exclusive operations
    insert!(e, q) == (enqueue!(e, q); q)
    extract! q == dequeue! q
    inspect q == front q

)abbrev domain DEQUEUE Dequeue
++ Author: Michael Monagan and Stephen Watt
++ Date Created: June 86 and July 87
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:

Dequeue(S : SetCategory) : DequeueAggregate S with
     dequeue : List S -> %
       ++ dequeue([x, y, ..., z]) creates a dequeue with first (top or front)
       ++ element x, second element y, ..., and last (bottom or back) element z.
  == Queue S add
    Rep := Record(front: List S, rear: List S)

    -- empty, empty? copy, map, map!, #, parts, hashUpdate! are provided by Queue S
    dequeue d == [copy d, []]
    construct d == dequeue d

    -- if front or rear is empty, try to balance the dequeue
    -- balance! try to ensure front non-empty, unless the dequeue is empty
    balance!(d : %) : % ==
        if empty? d.front then
            empty? d.rear => return d
            n := # d.rear
            n = 1 =>
                d.front := d.rear
                d.rear := []
                return d
            d.front := reverse! split!(d.rear, n quo 2)
            return d
        if empty? d.rear then
            n := # d.front
            n = 1 => return d
            d.rear := reverse! split!(d.front, n quo 2)
        d

    -- DequeueAggregate's exclusive operations
    extractTop! d ==
        if empty? d.front then
            empty? d.rear => error "empty dequeue"
            balance! d
        e := first d.front
        d.front := rest d.front
        e

    extractBottom! d ==
        if empty? d.rear then
            empty? d.front => error "empty dequeue"
            if null rest d.front then
                -- have 1 element in d
                e := first d.front
                d.front := []
                return e
            balance! d
        e := first d.rear
        d.rear := rest d.rear
        e

    insertTop!(e, d) ==
        d.front := cons(e, d.front)
        e

    insertBottom!(e, d) ==
        d.rear := cons(e, d.rear)
        e

    reverse! d ==
        empty? d => d
        (d.front, d.rear) := (d.rear, d.front)
        d

    bottom d ==
        empty? d.rear =>
            empty? d.front => error "empty dequeue"
            last d.front
        first d.rear

    -- QueueAggregate's exclusive operations
    front d ==
        empty? d.front =>
            empty? d.rear => error "empty dequeue"
            last d.rear
        first d.front
    enqueue!(e, d) == insertBottom!(e, d)
    dequeue! d == extractTop! d
    back d == bottom d

    -- StackAggregate's exclusive operations
    top d == front d
    pop! d == extractTop! d
    push!(e, d) == insertTop!(e, d)

    -- BagAggregate's exclusive operations
    insert!(e, d) == (insertBottom!(e, d); d)
    extract! d == extractTop! d
    inspect d == front d

)abbrev domain HEAP Heap
++ Author: Michael Monagan and Stephen Watt
++ Date Created: June 86 and July 87
++ Basic Operations:
++ Related Domains:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ Examples:
++ References:
++ Description:

++ Heap implemented in a flexible array to allow for insertions
++ Complexity: O(log n) insertion, extraction and O(n) construction
--% Dequeue and Heap data types

Heap(S : OrderedSet) : Exports == Implementation where
  Exports == PriorityQueueAggregate S with
    heap : List S -> %
      ++ heap(ls) creates a heap of elements consisting of the
      ++ elements of ls.
  Implementation == IndexedFlexibleArray(S, 0) add
    Rep := IndexedFlexibleArray(S, 0)
    empty() == empty()$Rep
    heap l == construct(l)
    siftUp : (%, Integer, Integer) -> Void
    siftUp(r, i, n) ==
       -- assertion 0 <= i < n
       t := r.i
       while (j := 2*i+1) < n repeat
          if (k := j+1) < n and r.j < r.k then j := k
          if t < r.j then (r.i := r.j; r.j := t; i := j) else break

    extract! r ==
       -- extract the maximum from the heap O(log n)
       n := #r :: Integer
       n = 0 => error "empty heap"
       t := r(0)
       r(0) := r(n-1)
       delete!(r, n-1)
       n = 1 => t
       siftUp(r, 0, n-1)
       t

    insert!(x, r) ==
       -- Williams' insertion algorithm O(log n)
       j := (#r) :: Integer
       r := concat!(r, concat(x, empty()$Rep))
       while j > 0 repeat
          i := (j-1) quo 2
          if r(i) >= x then break
          r(j) := r(i)
          j := i
       r(j) := x
       r

    max r == if #r = 0 then error "empty heap" else r.0
    inspect r == max r

    makeHeap(r : %) : % ==
       -- Floyd's heap construction algorithm O(n)
       n := #r
       for k in n quo 2 -1 .. 0 by -1 repeat siftUp(r, k, n)
       r
    construct l == makeHeap construct(l)$Rep
    merge(a, b) == makeHeap concat(a, b)
    merge!(a, b) == makeHeap concat!(a, b)

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
