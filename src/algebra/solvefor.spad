)abbrev package SOLVEFOR PolynomialSolveByFormulas
++ Author: Stephen M. Watt, Barry Trager
++ Description:
++ This package factors the formulas out of the general solve code,
++ allowing their recursive use over different domains.
++ Care is taken to introduce few radicals so that radical extension
++ domains can more easily simplify the results.

PolynomialSolveByFormulas(R, UP) : PSFcat == PSFdef where
    R : Join(PolynomialFactorizationExplicit, Comparable, CharacteristicZero)
    F ==> Polynomial R
    RF ==> Fraction F
    UP : UnivariatePolynomialCategory F
    EXPR ==> Expression R

    L  ==> List

    PSFcat == with
        solve : UP -> L EXPR
                ++ solve(u) \undocumented
        particularSolution : UP -> EXPR
                ++ particularSolution(u) \undocumented
        linear : UP -> L EXPR
                ++ linear(u) \undocumented
        quadratic : UP -> L EXPR
                ++ quadratic(u) \undocumented
        cubic : UP -> L EXPR
                ++ cubic(u) \undocumented
        quartic : UP -> L EXPR
                ++ quartic(u) \undocumented

        -- Arguments give coeffs from high to low degree.
        linear : (F, F) -> L EXPR
                ++ linear(f, g) \undocumented
        quadratic : (F, F, F) -> L EXPR
                ++ quadratic(f, g, h) \undocumented
        linear2 : (EXPR, EXPR) -> L EXPR
                ++ linear(f, g) \undocumented
        quadratic2 : (EXPR, EXPR, EXPR) -> L EXPR
                ++ quadratic(f, g, h) \undocumented
        cubic : (F, F, F, F) -> L EXPR
                ++ cubic(f, g, h, i) \undocumented
        quartic : (F, F, F, F, F) -> L EXPR
                ++ quartic(f, g, h, i, j) \undocumented

        aLinear : (F, F) -> EXPR
                ++ aLinear(f, g) \undocumented
        aQuadratic : (F, F, F) -> EXPR
        aQuadratic2 : (EXPR, EXPR, EXPR) -> EXPR
                ++ aQuadratic(f, g, h) \undocumented
        aCubic : (RF, RF, RF, RF) -> EXPR
                ++ aCubic(f, g, h, j) \undocumented
        aQuartic : (F, F, F, F, F) -> EXPR
                ++ aQuartic(f, g, h, i, k) \undocumented
    PSFdef == add

        (f : RF ^ n : Fraction Integer) : EXPR == (f::EXPR)^n

        (f : RF / n : Integer) : RF == f/n::RF

        part(s : RF) : EXPR ==
            s::EXPR

        part2(s : F) : EXPR ==
            -- part2(s) returns a*b^(1/2), the simplification of s^(1/2).
            -- Note that the sign of 'a' is not important, because both
            -- roots will be used.
            sqfr := squareFree s
            -- coeff := unit sqfr -- this is only needed if F is polynomial,
            -- where unit is not factored.
            a := "*"/[f.factor^(f.exponent quo 2) for f in factorList sqfr]
            b := "*"/[f.factor^(f.exponent rem 2) for f in factorList sqfr]
            -- the coefficient should also be factored.
            u : R := retract unit sqfr
            sqfru := squareFree u
            ua := "*"/[f.factor^(f.exponent quo 2) for f in factorList sqfru]
            ub := "*"/[f.factor^(f.exponent rem 2) for f in factorList sqfru]
            (ua*a)::EXPR*(unit(sqfru)*ub*b::EXPR)^(1/2)


        -----------------------------------------------------------------
        -- Entry points and error handling
        -----------------------------------------------------------------
        cc ==> coefficient

        -- local intsolve
        intsolve(u : UP) : L EXPR ==
            -- u has already been factored.
            n := degree u
            n = 1 => linear    (cc(u, 1), cc(u, 0))
            n = 2 => quadratic (cc(u, 2), cc(u, 1), cc(u, 0))
            n = 3 => cubic     (cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))
            n = 4 => quartic   (cc(u, 4), cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))
            error "All sqfr factors of polynomial must be of degree < 5"

        solve u ==
            ls := []$L(EXPR)
            for f in factorList squareFree u repeat
               lsf := intsolve f.factor
               for i in 1..(f.exponent) repeat ls := concat(lsf, ls)
            ls

        particularSolution u ==
            u := (factorList squareFree u).1.factor
            n := degree u
            n = 1 => aLinear    (cc(u, 1), cc(u, 0))
            n = 2 => aQuadratic (cc(u, 2), cc(u, 1), cc(u, 0))
            n = 3 => aCubic     (cc(u, 3)::RF, cc(u, 2)::RF, cc(u, 1)::RF, cc(u, 0)::RF)
            n = 4 => aQuartic   (cc(u, 4), cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))
            error "All sqfr factors of polynomial must be of degree < 5"

        needDegree(n : Integer, u : UP) : Boolean ==
            degree u = n => true
            error concat("Polynomial must be of degree ", convert(n)@String)

        needLcoef(cn : F) : Boolean ==
            cn ~= 0 => true
            error "Leading coefficient must not be 0."

        needChar0() : Boolean ==
            characteristic()$F = 0 => true
            error "Formula defined only for fields of characteristic 0."

        linear u ==
            needDegree(1, u)
            linear(cc(u, 1), cc(u, 0))

        quadratic u ==
            needDegree(2, u)
            quadratic(cc(u, 2), cc(u, 1), cc(u, 0))

        cubic u ==
            needDegree(3, u)
            cubic(cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))

        quartic u ==
            needDegree(4, u)
            quartic(cc(u, 4), cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))

        -----------------------------------------------------------------
        -- The formulas
        -----------------------------------------------------------------

        -- local function for testing equality of radicals.
        --  This function is necessary to detect at least some of the
        --  situations like sqrt(9)-3 = 0 --> false.
        equ(x : RF, y : RF) : Boolean ==
            ( (recip(x-y)) case "failed" ) => true
            false

        linear(c1, c0) ==
            needLcoef c1
            [(-c0/c1)::EXPR]

        linear2(c1, c0) ==
            --needLcoef c1
            [-c0/c1]

        aLinear(c1, c0) ==
            first linear(c1, c0)

        quadratic(c2, c1, c0) ==
            needLcoef c2; needChar0()
            c0 = 0 => cons(0$EXPR, linear(c2, c1))
            c1 = 0 => [(-c0/c2)^(1/2), -(-c0/c2)^(1/2)]
            D := part2(c1^2 - 4*c2*c0)
            cc1 : EXPR := coerce(c1)
            cc2 : EXPR := coerce(c2)
            [(- cc1 + D)/(2 * cc2), (- cc1 - D)/(2 * cc2)]

        quadratic2(c2, c1, c0) ==
            --needLcoef c2;
            needChar0()
            c0 = 0 => cons(0$EXPR, linear2(c2, c1))
            c1 = 0 => [(-c0/c2)^(1/2), -(-c0/c2)^(1/2)]
            D := (c1^2 - 4*c2*c0)^(1/2)
            [(- c1 + D)/(2 * c2), (- c1 - D)/(2 * c2)]

        aQuadratic(c2, c1, c0) ==
            needLcoef c2; needChar0()
            c0 = 0 => 0$EXPR
            c1 = 0 => (-c0/c2)^(1/2)
            D := part2(c1^2 - 4*c2*c0)
            (-c1::EXPR+D)/(2*c2::EXPR)

        aQuadratic2(c2, c1, c0) ==
            --needLcoef c2;
            needChar0()
            c0 = 0 => 0$EXPR
            c1 = 0 => (-c0/c2)^(1/2)
            D := (c1^2 - 4*c2*c0)^(1/2)
            (- c1 + D)/(2 * c2)


        cubic(c3, c2, c1, c0) ==
            needLcoef c3; needChar0()

            w3 : EXPR := (-1 + (-3::EXPR)^(1/2)) / 2::EXPR

            -- case one root = 0, not necessary but keeps result small
            (c0 = 0) => cons(0$EXPR, quadratic(c3, c2, c1))
            a1 : RF := c2/c3;  a2 : RF := c1/c3;  a3 : RF := c0/c3

            -- case x^3-a3 = 0, not necessary but keeps result small
            (a1 = 0 and a2 = 0) =>
                [ u*(-a3)^(1/3) for u in [1, w3, w3^2 ] ]

            -- case x^3 + a1*x^2 + a1^2*x/3 + a3 = 0, the general formula
            -- is not valid in this case, but solution is easy.
            p := part(-a1/3)
            equ(a1^2, 3*a2) =>
              s : EXPR := (- a3 + a1^3/27)^(1/3)
              [ p + s*u for u in [1, w3, w3^2] ]

            -- general case
            q : EXPR := coerce((3*a2 - a1^2)/9)
            -- temporary variable to speed up complication
            tmpr : RF := 9*a1*a2 - 27*a3 - 2*a1^3
            r : EXPR := coerce(tmpr/54)
            d : EXPR := (q^3 + r^2)^(1/2)
            s : EXPR := (r + d)^(1/3)
            -- s = 0 is done in the previous case
            [ p + s*u - q/(s*u) for u in [1, w3, w3^2] ]

        aCubic(c3, c2, c1, c0) ==
            --needLcoef c3;
            needChar0()
            (c0 = 0) => 0$EXPR
            a1 : RF := c2/c3;  a2 : RF := c1/c3;  a3 : RF := c0/c3
            (a1 = 0 and a2 = 0) => (-a3)^(1/3)
            p := coerce(-a1/3)
            equ(a1^2, 3*a2) =>
              s := (- a3 + a1^3/27)^(1/3)
              p + s
            q : EXPR := coerce((3*a2 - a1^2)/9)
            -- temporary variable to speed up complication
            tmpr : RF := 9*a1*a2 - 27*a3 - 2*a1^3
            r : EXPR := coerce(tmpr/54)
            d : EXPR := (q^3 + r^2)^(1/2)
            s := (r + d)^(1/3)
            p + s - q/s

        quartic(c4, c3, c2, c1, c0) ==
            needLcoef c4; needChar0()

            -- case one root = 0, not necessary but keeps result small
            c0 = 0 => cons(0$EXPR, cubic(c4, c3, c2, c1))
            -- Make monic:
            a1 : RF := c3 / c4; a2 : RF := c2 / c4
            a3 : RF := c1 / c4; a4 : RF := c0 / c4

            -- case x^4 + a4 = 0 <=> (x^2-sqrt(-a4))*(x^2+sqrt(-a4))
            -- not necessary but keeps result small. -- PART2(-A4) -- NOTE MEEEEEEEEEEEEEEEE
            (a1 = 0 and a2 = 0 and a3 = 0) =>
                append( quadratic2(1, 0, (-a4)^(1/2)), _
                        quadratic2(1, 0, -(-a4)^(1/2)) )

            -- Translate w = x+a1/4 to eliminate a1:  w^4+p*w^2+q*w+r
            p : RF := a2 - 3 * a1 * a1/8
            q : RF := a3 - a1 * a2/2 + a1^3/8
            r : RF := a4 - a1 * a3/4 + a1^2 * a2/16 - 3 * a1^4/256
            -- t0 := the cubic resolvent of x^3-p*x^2-4*r*x+4*p*r-q^2
            -- The roots of the translated polynomial are those of
            -- two quadratics. (What about rt=0 ?)
            -- rt=0 can be avoided by picking a root ~= p of the cubic
            -- polynomial above. This is always possible provided that
            -- the input is squarefree. In this case the two other roots
            -- are +(-) 2*r^(1/2).
            t0 : EXPR :=            -- this means p is a root
                equ(q, 0) => 2*r^(1/2)
                aCubic(1, -p, -4*r, 4*p*r - q^2)
            rt : EXPR := (t0 - p::EXPR)^(1/2)
            slist := append( quadratic2( 1,  rt, (-q::EXPR/rt + t0)/2::EXPR ),
                             quadratic2( 1, -rt, ( q::EXPR/rt + t0)/2::EXPR ))
            -- Translate back:
            [s - coerce(a1/4) for s in slist]

        aQuartic(c4, c3, c2, c1, c0) ==
            needLcoef c4; needChar0()
            c0 = 0 => 0$EXPR
            a1 : RF := c3 / c4; a2 : RF := c2 / c4
            a3 : RF := c1 / c4; a4 : RF := c0 / c4
            (a1 = 0 and a2 = 0 and a3 = 0) => (-a4)^(1/4)
            p  := a2 - 3 * a1 * a1/8
            q  := a3 - a1 * a2/2 + a1^2 * a1/8
            r  := a4 - a1 * a3/4 + a1^2 * a2/16 - 3 * a1^4/256
            t0 : EXPR :=
                equ(q, 0) => 2*r^(1/2)
                aCubic(1, -p, -4*r, 4*p*r - q^2)
            rt : EXPR := (t0 - p::EXPR)^(1/2)
            s  := aQuadratic2(1,  rt, (-coerce(q)/rt + t0)/2::EXPR)
            s - coerce(a1/4)

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
