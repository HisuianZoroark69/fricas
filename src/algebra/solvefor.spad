)abbrev package SOLVEFOR PolynomialSolveByFormulas
-- Examples of fields with "^": (%, Fraction Integer) -> % are
--     Complex Float, RealClosure(K) and AlgebraicNumber
-- RealClosure(K) is unlikly to work here...
++ Author: Stephen M. Watt, Barry Trager
++ Description:
++ This package factors the formulas out of the general solve code,
++ allowing their recursive use over different domains.
++ Care is taken to introduce few radicals so that radical extension
++ domains can more easily simplify the results.

PolynomialSolveByFormulas(R) : PSFcat == PSFdef where
    R : Join(PolynomialFactorizationExplicit, Comparable, CharacteristicZero)
    PR ==> Polynomial R
    UP ==> SparseUnivariatePolynomial PR
    RF ==> Fraction PR
    F ==> Expression R
    L ==> List

    PSFcat == with
        solve :      UP -> L F
                ++ solve(u) \undocumented
        particularSolution :  UP -> F
                ++ particularSolution(u) \undocumented
        linear :     UP -> L F
                ++ linear(u) \undocumented
        quadratic :  UP -> L F
                ++ quadratic(u) \undocumented
        cubic :      UP -> L F
                ++ cubic(u) \undocumented
        quartic :    UP -> L F
                ++ quartic(u) \undocumented

        -- Arguments give coefs from high to low degree.
        linear : (PR, PR) -> L F
                ++ linear(f, g) \undocumented
        quadratic : (PR, PR, PR) -> L F
                ++ quadratic(f, g, h) \undocumented
        quadratic2 : (F, F, F) -> L F
                ++ quadratic(f, g, h) \undocumented
        cubic : (PR, PR, PR, PR) -> L F
                ++ cubic(f, g, h, i) \undocumented
        quartic : (PR, PR, PR, PR, PR) -> L F
                ++ quartic(f, g, h, i, j) \undocumented

        aLinear : (PR, PR) -> F
                ++ aLinear(f, g) \undocumented
        aQuadratic : (F, F, F) -> F
                ++ aQuadratic(f, g, h) \undocumented
        aCubic : (RF, RF, RF, RF) -> F
                ++ aCubic(f, g, h, j) \undocumented
        aQuartic : (PR, PR, PR, PR, PR) -> F
                ++ aQuartic(f, g, h, i, k) \undocumented

    PSFdef == add
        -- The following 4 functions provides automatic coercion,
        -- to reduce the need of manual coercion.

        (f : RF ^ n : Fraction Integer) : F == (f::F)^n

        (f : PR + e : F) : F == f::F + e

        (f : PR - e : F) : F == f::F - e

        (e : F / f : PR) : F == e/f::F

        sqrt2(s : PR) : F ==
            -- sqrt2(s) returns a square root of 's', and simplifies it to
            -- the form of 'a*b^(1/2)', where 'a' and 'b' are both polynomials.
            -- Note that the sign of 'a' is not important, because both roots
            -- ('a*b^(1/2)' and '-a*b^(1/2)') will be used later.

            sqfr := squareFree s
            a := "*"/[f.factor^(f.exponent quo 2) for f in factorList sqfr]
            b := "*"/[f.factor^(f.exponent rem 2) for f in factorList sqfr]

            -- the coefficient should also be factored.
            u : R := retract unit sqfr
            sqfru := squareFree u
            ua := "*"/[f.factor^(f.exponent quo 2) for f in factorList sqfru]
            ub := "*"/[f.factor^(f.exponent rem 2) for f in factorList sqfru]
            (ua * a)::F * (unit(sqfru) * ub * b::F)^(1/2)

        -----------------------------------------------------------------
        -- Entry points and error handling
        -----------------------------------------------------------------
        cc ==> coefficient

        -- local intsolve
        intsolve(u : UP) : L(F) ==
            -- u is already factored
            n := degree u
            n = 1 => linear    (cc(u, 1), cc(u, 0))
            n = 2 => quadratic (cc(u, 2), cc(u, 1), cc(u, 0))
            n = 3 => cubic     (cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))
            n = 4 => quartic   (cc(u, 4), cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))
            error "All sqfr factors of polynomial must be of degree < 5"

        solve u ==
            ls := []$L(F)
            for f in factorList squareFree u repeat
               lsf := intsolve f.factor
               for i in 1..(f.exponent) repeat ls := concat(lsf, ls)
            ls

        particularSolution u ==
            u := (factorList squareFree u).1.factor
            n := degree u
            n = 1 => aLinear    (cc(u, 1), cc(u, 0))
            n = 2 => aQuadratic (cc(u, 2)::F, cc(u, 1)::F, cc(u, 0)::F)
            n = 3 => aCubic     (cc(u, 3)::RF, cc(u, 2)::RF, cc(u, 1)::RF, cc(u, 0)::RF)
            n = 4 => aQuartic   (cc(u, 4), cc(u, 3), cc(u, 2), cc(u, 1), cc(u, 0))
            error "All sqfr factors of polynomial must be of degree < 5"

        needDegree(n : Integer, u : UP) : Boolean ==
            degree u = n => true
            error concat("Polynomial must be of degree ", convert(n)@String)

        needLcoef cn ==> cn = 0 => error "Leading coefficient must not be 0."

        needChar0() : Boolean ==
            characteristic()$PR = 0 => true
            error "Formula defined only for fields of characteristic 0."

        linear u ==
            needDegree(1, u)
            linear (coefficient(u, 1), coefficient(u, 0))

        quadratic u ==
            needDegree(2, u)
            quadratic (coefficient(u, 2), coefficient(u, 1),
                       coefficient(u, 0))

        cubic u ==
            needDegree(3, u)
            cubic (coefficient(u, 3), coefficient(u, 2),
                   coefficient(u, 1), coefficient(u, 0))

        quartic u ==
            needDegree(4, u)
            quartic (coefficient(u, 4), coefficient(u, 3),
                     coefficient(u, 2), coefficient(u, 1), coefficient(u, 0))

        -----------------------------------------------------------------
        -- The formulas
        -----------------------------------------------------------------

        -- local function for testing equality of radicals.
        --  This function is necessary to detect at least some of the
        --  situations like sqrt(9)-3 = 0 --> false.
        equ(x : RF, y : RF) : Boolean ==
            ( (recip(x-y)) case "failed" ) => true
            false

        linear(c1, c0) ==
            needLcoef c1
            [(-c0::F/c1)]

        aLinear(c1, c0) ==
            first linear(c1, c0)

        quadratic(c2, c1, c0) ==
            needLcoef c2; needChar0()
            (c0 = 0) => cons(0$F, linear(c2, c1))
            (c1 = 0) => [(-c0/c2)^(1/2), -(-c0/c2)^(1/2)]
            D := sqrt2(c1^2 - 4*c2*c0)
            [(-c1+D)/(2*c2), (-c1-D)/(2*c2)]

        aQuadratic(c2, c1, c0) ==
            needLcoef c2; needChar0()
            (c0 = 0) => 0$F
            (c1 = 0) => (-c0/c2)^(1/2)
            D := (c1^2 - 4*c2*c0)^(1/2)
            (-c1+D)/(2*c2)

        w3 : F := (-1 + (-3::F)^(1/2)) / 2::F

        cubic(c3, c2, c1, c0) ==
            needLcoef c3; needChar0()

            -- case one root = 0, not necessary but keeps result small
            (c0 = 0) => cons(0$F, quadratic(c3, c2, c1))
            a1 : RF := c2/c3;  a2 : RF := c1/c3;  a3 : RF := c0/c3

            -- case x^3-a3 = 0, not necessary but keeps result small
            (a1 = 0 and a2 = 0) =>
                [ u*(-a3)^(1/3) for u in [1, w3, w3^2 ] ]

            -- case x^3 + a1*x^2 + a1^2*x/3 + a3 = 0, the general for-
            --   mula is not valid in this case, but solution is easy.
            p := (-1/3*a1)::F
            equ(a1^2, 3*a2) =>
              s : F := (-a3 + 1/27*a1^3)^(1/3)
              [ p + s*u for u in [1, w3, w3^2] ]

            -- general case
            q := (1/9*(3*a2 - a1^2))::F
            -- this temporary variable is needed to speed up complication
            tmpr : RF := 9*a1*a2 - 27*a3 - 2*a1^3
            r := (1/54*tmpr)::F
            d := (q^3 + r^2)^(1/2)
            s := (r + d)^(1/3)
            -- s = 0 is done in the previous case
            [ p + s*u - q/(s*u) for u in [1, w3, w3^2] ]

        aCubic(c3, c2, c1, c0) ==
            needLcoef c3; needChar0()
            (c0 = 0) => 0$F
            a1 : RF := c2/c3; a2 : RF := c1/c3; a3 : RF := c0/c3
            (a1 = 0 and a2 = 0) => (-a3)^(1/3)
            p := (-1/3*a1)::F
            equ(a1^2, 3*a2) =>
              s := (-a3 + 1/27*a1^3)^(1/3)
              p + s
            q := (1/9*(3*a2 - a1^2))::F
            -- temporary variable to speed up complication
            tmpr : RF := 9*a1*a2 - 27*a3 - 2*a1^3
            r := (1/54*tmpr)::F
            d := (q^3 + r^2)^(1/2)
            s := (r + d)^(1/3)
            p + s - q/s

        quartic(c4, c3, c2, c1, c0) ==
            needLcoef c4; needChar0()

            -- case one root = 0, not necessary but keeps result small
            (c0 = 0) => cons(0$F, cubic(c4, c3, c2, c1))
            -- Make monic:
            a1 : RF := c3/c4; a2 : RF := c2/c4
            a3 : RF := c1/c4; a4 : RF := c0/c4

            -- case x^4 + a4 = 0 <=> (x^2-sqrt(-a4))*(x^2+sqrt(-a4))
            -- not necessary but keeps result small.
            (a1 = 0 and a2 = 0 and a3 = 0) =>
                append(quadratic2(1, 0, (-a4)^(1/2)),
                       quadratic2(1, 0, -((-a4)^(1/2))))

            -- Translate w = x+a1/4 to eliminate a1:  w^4+p*w^2+q*w+r
            p : RF := 1/8*(8*a2 - 3*a1^2)
            q : RF := 1/8*(8*a3 - 4*a1*a2 + a1^3)
            r : RF := 1/256*(256*a4 - 64*a1*a3 + 16*a1^2*a2 - 3*a1^4)
            -- t0 := the cubic resolvent of x^3-p*x^2-4*r*x+4*p*r-q^2
            -- The roots of the translated polynomial are those of
            -- two quadratics. (What about rt=0 ?)
            -- rt=0 can be avoided by picking a root ~= p of the cubic
            -- polynomial above. This is always possible provided that
            -- the input is squarefree. In this case the two other roots
            -- are +(-) 2*r^(1/2).
            if equ(q, 0)            -- this means p is a root
              then t0 := 2*r^(1/2)
              else t0 := aCubic(1, -p, -4*r, 4*p*r - q^2)
            rt    := (t0 - p::F)^(1/2)
            slist := append(quadratic2(1,  rt, 1/2*(-q::F/rt + t0)),
                            quadratic2(1, -rt, 1/2*( q::F/rt + t0)))
            -- Translate back:
            [s - (1/4*a1)::F for s in slist]

        aQuartic(c4, c3, c2, c1, c0) ==
            needLcoef c4; needChar0()
            (c0 = 0) => 0$F
            a1 : RF := c3/c4; a2 : RF := c2/c4
            a3 : RF := c1/c4; a4 : RF := c0/c4
            (a1 = 0 and a2 = 0 and a3 = 0) => (-a4)^(1/4)
            p : RF := 1/8*(8*a2 - 3*a1^2)
            q : RF := 1/8*(8*a3 - 4*a1*a2 + a1^3)
            r : RF := 1/256*(256*a4 - 64*a1*a3 + 16*a1^2*a2 - 3*a1^4)
            if equ(q, 0)
              then t0 := 2*(r^(1/2))
              else t0 := aCubic(1, -p, -4*r, 4*p*r - q^2)
            rt := (t0 - p::F)^(1/2)
            s  := aQuadratic(1, rt, 1/2*(-q::F/rt + t0))
            s - (1/4*a1)::F

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
