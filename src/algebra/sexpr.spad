)abbrev domain SEXPR SymbolicExpression
++ Unevaluated mathematical expressions
++ Author: Bill Page
++ Date Created: 15 Novermber 2016
++ Description:
++ Expressions involving symbolic functions that remain unevaluated and are
++ displayed as entered. Evaluation is delayed until an operation is performed
++ which requires a canonical form such as testing for equality or
++ simplification. The domain depends directly internally on the Expression
++ domain for evaluation of expressions.
++ Keywords: expression, evaluation, operator, function.
SymbolicExpression(R : Join(Comparable,ConvertibleTo(InputForm))) : Exports == Implementation where
  F ==> Expression R
  K   ==> Kernel %
  MP  ==> SparseMultivariatePolynomial(R, K)
  AF  ==> AlgebraicFunction(R, F)
  EF  ==> ElementaryFunction(R, F)
  CF  ==> CombinatorialFunction(R, F)
  LF  ==> LiouvillianFunction(R, F)
  AN  ==> AlgebraicNumber
  KAN ==> Kernel AN
  ESD ==> ExpressionSpace_&(F)
  FSD ==> FunctionSpace_&(F, R)

  Exports ==> Join(Comparable,ConvertibleTo(InputForm),CoercibleTo(OutputForm)) with
    if R has IntegralDomain then
      Ring
      AlgebraicallyClosedFunctionSpace R
      TranscendentalFunctionCategory
      CombinatorialOpsCategory
      LiouvillianFunctionCategory
      SpecialFunctionCategory
      -- transformations
      expand: % -> %
    if F has FunctionSpace(Integer) then
      factor: % -> %


    -- coercions and conversions
    coerce: Symbol -> %
    coerce: F -> %
    coerce: R -> %
    coerce: Pi -> %
    convert: % -> Expression R
    retract: % -> Symbol
    retract: % -> R

    -- transformations
    eval: (%,%,%) -> %
    eval: (%,Equation %) -> %
    simplify : % -> %
    subst: (%,Equation %) -> %

  Implementation ==> add
    Rep := InputForm
    eval(x:%,a:%,b:%):% == coerce eval(convert(x)@F, convert(a)@F, convert(b)@F)
    eval(x:%,e:Equation %):% == eval(x,lhs e,rhs e)
    subst(x:%,e:Equation %):% == SUBST(rhs(e)::Rep,lhs(e)::Rep,x::Rep)$Lisp
    retract(x:%):Symbol == retract(convert(x)@F)$F

    if R has IntegralDomain then
      0:% == convert(0$F)@InputForm
      1:% == convert(1$F)@InputForm
      one? x  == (x = 1)$Rep
      zero? x == (x = 0)$Rep
      --numer(x:%):% == coerce numerator(convert x)$F
      --denom(x:%):% == coerce denominator(convert x)$F
      numerator(x:%):% == coerce numerator(convert x)$F
      denominator(x:%):% == coerce denominator(convert x)$F
      factorials(x:%):%           == coerce factorials(convert x)$CF
      factorials(x:%, n:Symbol):% == coerce factorials(convert x, n)$CF
      expand(x:%):% ==
        d := isPlus denominator(convert x)$F
        if d case List F then
          n := numerator(x)
          return reduce((p:%,q:%):%+->p+q,[n/coerce(s) for s in d])
        else
          return x

    if F has FunctionSpace(Integer) then
      factor(x:%):% ==
        (factor(numer(convert(x)@F)$F)::OutputForm pretend InputForm /
          factor(denom(convert(x)@F)$F)::OutputForm pretend InputForm)$InputForm

    coerce(x:Pi):% == convert(x)@InputForm
    coerce(x:Symbol):% == convert(x)@InputForm

    coerce1(x:Rep):OutputForm ==
      if null? x then return empty()$OutputForm
      if atom? x then return (x pretend OutputForm)
      if list? x and symbol? car x then
        s := symbol car x
        if s='float then
          return interpret(x)$InputFormFunctions1(Float)::OutputForm
        if s='factorial then
          if list? car(cdr x) then
            return postfix(outputForm '_!, paren coerce1 car cdr x)
          else
            return postfix(outputForm '_!, coerce1 car cdr x)
        if s='sum or s='summation then
            return sum(coerce1 car cdr x, coerce1 car cdr cdr x)
        if s='product then
            return prod(coerce1 car cdr x, coerce1 car cdr cdr x)
        if s='binomial then
            return binomial(coerce1 car cdr x, coerce1 car cdr cdr x)
        if s='sqrt then
            return root coerce1 car cdr x
        if member?(s,['_+,'_-,'_*,'_/,'_^])$List(Symbol) and #cdr(x)>1 then
          return infix(outputForm s, [coerce1(i) for i in destruct cdr x])
        else
          if list? car(cdr x) then
            return prefix(hconcat(outputForm s,hspace(1)), [coerce1(i) for i in destruct cdr x])
          else
            return hconcat([outputForm s, hspace(1), coerce1 car cdr x])
      return hconcat(message("what is:")$OutputForm,x pretend OutputForm)
    coerce(x:%):OutputForm == coerce1(x pretend Rep) -- x pretend OutputForm

    -- +0 is a hack to avoid premature conversion
    hack(x:%):Rep == binary(convert('_+),[x::Rep,0::Rep])$InputForm
    convert(x:%):F == interpret(hack x)$InputFormFunctions1(F)
    coerce(x:R):% == convert(x)@InputForm
    coerce(x:F):% == convert(x)@InputForm
    convert(x:%):InputForm == x pretend Rep
    --
    (x:% ^ y:%):% == binary(convert('_^),[x::Rep,y::Rep])$InputForm
    (x:% ^ y:PositiveInteger):% ==
      binary(convert('_^),[x::Rep,y::Rep])$InputForm
    (x:% ^ y:NonNegativeInteger):% ==
      binary(convert('_^),[x::Rep,y::Rep])$InputForm

    factorial(x:%):%          == convert([convert('factorial)@InputForm,x::Rep])
    binomial(n:%, m:%):%      == binary(convert('binomial),[n::Rep,m::Rep])$InputForm
    permutation(n:%, m:%):%   == binary(convert('permutation),[n::Rep,m::Rep])$InputForm
    sum(x : %, n : Symbol):%           == binary(convert('sum),[x::Rep,convert(n)@InputForm])$InputForm
    sum(x : %, s : SegmentBinding %):% == binary(convert('sum),[x::Rep,convert(s)@InputForm])$InputForm
    summation(x : %, n : Symbol):%           == binary(convert('summation),[x::Rep,convert(n)@InputForm])$InputForm
    summation(x : %, s : SegmentBinding %):% == binary(convert('summation),[x::Rep,convert(s)@InputForm])$InputForm
    product(x : %, n : Symbol):%             == binary(convert('product),[x::Rep,convert(n)@InputForm])$InputForm
    product(x : %, s : SegmentBinding %):%   == binary(convert('product),[x::Rep,convert(s)@InputForm])$InputForm

    -- We don't want any InputForm +0 and *1 auto-simplification
    (x:% + y:%):% == binary(convert('_+),[x::Rep,y::Rep])$InputForm
    (x:% - y:%):% == binary(convert('_-),[x::Rep,y::Rep])$InputForm
    (x:% * y:%):% == binary(convert('_*),[x::Rep,y::Rep])$InputForm
    (x:% / y:%):% == binary(convert('_/),[x::Rep,y::Rep])$InputForm
    (x:Integer * y:%):% == convert(x)@InputForm * y
    _-(x:%):% == convert([convert('_-)@InputForm,x::Rep])
    -- Elementary Functions
    acos(x:%):% == convert([convert('acos)@InputForm,x::Rep])
    acosh(x:%):% == convert([convert('acosh)@InputForm,x::Rep])
    acot(x:%):% == convert([convert('acot)@InputForm,x::Rep])
    acoth(x:%):% == convert([convert('acoth)@InputForm,x::Rep])
    acsc(x:%):% == convert([convert('acsc)@InputForm,x::Rep])
    acsch(x:%):% == convert([convert('acsch)@InputForm,x::Rep])
    asec(x:%):% == convert([convert('asec)@InputForm,x::Rep])
    asech(x:%):% == convert([convert('asech)@InputForm,x::Rep])
    asin(x:%):% == convert([convert('asin)@InputForm,x::Rep])
    asinh(x:%):% == convert([convert('asinh)@InputForm,x::Rep])
    atan(x:%):% == convert([convert('atan)@InputForm,x::Rep])
    atanh(x:%):% == convert([convert('atanh)@InputForm,x::Rep])
    cos(x:%):% == convert([convert('cos)@InputForm,x::Rep])
    cosh(x:%):% == convert([convert('cosh)@InputForm,x::Rep])
    cot(x:%):% == convert([convert('cot)@InputForm,x::Rep])
    coth(x:%):% == convert([convert('coth)@InputForm,x::Rep])
    csc(x:%):% == convert([convert('csc)@InputForm,x::Rep])
    csch(x:%):% == convert([convert('csch)@InputForm,x::Rep])
    exp(x:%):% == convert([convert('exp)@InputForm,x::Rep])
    log(x:%):% == convert([convert('log)@InputForm,x::Rep])
    --pi():% == convert([convert('pi)@InputForm])
    sec(x:%):% == convert([convert('sec)@InputForm,x::Rep])
    sech(x:%):% == convert([convert('sech)@InputForm,x::Rep])
    sin(x:%):% == convert([convert('sin)@InputForm,x::Rep])
    sinh(x:%):% == convert([convert('sinh)@InputForm,x::Rep])
    sqrt(x:%):% == convert([convert('sqrt)@InputForm,x::Rep])
    tan(x:%):% == convert([convert('tan)@InputForm,x::Rep])
    tanh(x:%):% == convert([convert('tanh)@InputForm,x::Rep])
    --
    retract(x:%):R == retract(convert(x)@F)$F
    variables(x:%):List Symbol == variables(convert x)$F
    -- use equality from Expression(R)
    (x:% = y:%):Boolean ==
      convert(x)@F = convert(x)@F

    if F has TranscendentalFunctionCategory then
      if F has FunctionSpace(Integer) then
        simplify(x:%):% ==
          convert(simplify(convert(x)@F)$TranscendentalManipulations(Integer,F))
      else
        if R has GcdDomain then
          simplify(x:%):% ==
            convert(simplify(convert(x)@F)$TranscendentalManipulations(R,F))
    else
      simplify(x:%):% == convert( convert(x)@F )
