)abbrev package SINF SINFunctions
SIN ==> InputForm
-- This should be built-in to InputForm, i.e. InputForm should satisfy Comparable
SINFunctions(): with
    smaller? : (SIN,SIN) -> Boolean
    rank: (Symbol,Integer) -> Symbol
    rank: Symbol -> Integer
  == add
    rank(x:Symbol,n:Integer):Symbol ==
      PUT(x,'rank,convert(n)@SIN)$Lisp
      x
    rank(x:Symbol):Integer ==
      r:SIN := GET(x,'rank)$Lisp
      integer? r => integer r
      0
    --null < integer < float < symbol rank < symbol rank < list
    --null < symbol rank < symbol rank < float < integer < list
    --null < symbol rank < symbol rank < list < float < integer
    smaller1?(x:SIN,y:SIN):Boolean ==
      if _$testingSystem$Lisp then
        output("smaller1? ",bracket [x::OutputForm,y::OutputForm])$OutputPackage
      null? y => return false
      symbol? y => null? x
        or symbol? x and (rank symbol x < rank symbol y
          or rank symbol y = rank symbol x and -- symbol x < symbol y)
          (symbol x = '_^ => '_*; symbol x = '_* => '_^; symbol x) < (symbol y = '_^ => '_*; symbol y = '_* => '_^; symbol y) )
      if list? y then
        if null? x then return true
        if atom? x then return smaller?(convert [convert([])@InputForm,x],y)
        if list? x then
          -- arguments
          x1:=cdr x; y1:=cdr y
          while not null? car x1 and not null? y1 repeat
            if null? car y1 then return true
            if smaller?(car x1, car y1) then return true
            if smaller?(car y1, car x1) then return false
            x1:=cdr x1; y1:=cdr y1
          -- operators
          return smaller?(car x,car y)
--          (# cdr x < # cdr y or (
--             # cdr x = # cdr y and # cdr x > 0 and (smaller?(cdr x,cdr y) or
--               not smaller?(cdr y, cdr x) and smaller?(car x,car y))))

--          smaller?(car x,car y) or
--            not smaller?(car y,car x) and # cdr x > 0 and smaller?(cdr x,cdr y)

--          (# cdr x < # cdr y or (
--             # cdr x = # cdr y and
--              (smaller?(car x,car y) or
--                not smaller?(car y,car x) and # cdr x > 0 and smaller?(cdr x,cdr y))))

--            (smaller?(cdr x,cdr y) or
--              not smaller?(cdr y, cdr x) and smaller?(car x,car y))))

--          (smaller?(car x,car y) or
--            not smaller?(car x, car y) and smaller?(cdr x, cdr y))

--          (smaller?(cdr x,cdr y) or
--             not smaller?(cdr y, cdr x) and smaller?(car x,car y))
      float? y => null? x or symbol? x
        or list? x and smaller?(x,convert [convert([])@InputForm,y])
          or float? x and float x < float y
      integer? y => null? x or symbol? x or float? x
        or list? x and smaller?(x,convert [convert([])@InputForm,y])
          or integer? x and integer x < integer y
      false
    smaller?(x:SIN,y:SIN):Boolean ==
      -- It is not yet proven that smaller? is a total order.
      -- smaller? == smaller1? except it checks for total order.
      -- To be removed in the future.
      if _$testingSystem$Lisp and smaller1?(x,y) and smaller1?(y,x) then
        output("smaller? ",bracket [x::OutputForm,y::OutputForm])$OutputPackage
        error("smaller? total order failed")
      else
        return smaller1?(x,y)

)abbrev category SYMCAT SymbolicCategory
SIN ==> InputForm
Maybe(S) ==> Union(S,"failed")
SymbolicCategory(R : Comparable) : Category == Exports where
  --F ==> Expression R
  Exports ==> Join(FunctionSpace R, CoercibleTo OutputForm, ConvertibleTo SIN) with
    axioms: () -> List Equation SIN
    -- Do we want these even if R not a Ring, e.g. Symbol ?
    _+: (%,%) -> %
    _-: (%,%) -> %
    _-: % -> %
    _*: (%,%) -> %
    _*:(PositiveInteger,%) -> %
    _*:(NonNegativeInteger,%) -> %
    _/: (%,%) -> %
    _^: (%,%) -> %
    _^: (%,Integer) -> %
    nthRoot: (%, %) -> %
    nthRoot: (%, Integer) -> %
    if R has IntegralDomain then
      Ring
      AlgebraicallyClosedFunctionSpace R
      TranscendentalFunctionCategory
      CombinatorialOpsCategory
      LiouvillianFunctionCategory
      SpecialFunctionCategory
      coerce: Polynomial R -> %
      -- transformations
      expand: % -> %
    if % has FunctionSpace(Integer) then
      factor: % -> %
    if % has TranscendentalFunctionCategory and R has GcdDomain then
      simplify : % -> %
    -- coercions
    coerce: Pi -> %
    coerce: % -> Expression(R)
    coerce: Expression(R) -> %
    convert: Equation % -> Equation SIN
    convert: Equation SIN -> Equation %
    coerce: SIN -> %
    --
    equal?: Equation % -> Boolean
    isMinus: % -> Maybe(List %)

)abbrev category AXIOM Axiom
++ Properties and axioms for symbolic rewrite rules
Axiom(): Category == Type with
    assert: (String,Boolean)->Void
  add
    -- Assertion (intended to be run at domain instantiation)
    assert(name:String,axiom:Boolean) ==
      if not axiom then error name
      else if _$testingSystem$Lisp then output(name)$OutputPackage

)abbrev category ALTAX AntiCommutativeAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ AntiCommutative
AntiCommutativeAxiom(): Category == Axiom with
    rewriteAntiCommutative: (SIN->SIN,(SIN,SIN)->SIN, SIN, SIN) -> Maybe(SIN)
  add
    rewriteAntiCommutative(m:SIN->SIN,f:(SIN,SIN)->SIN, x:SIN, y:SIN): Maybe(SIN) ==
      --output("rewriteAntiCommutative: ",paren [x::OutputForm,y::OutputForm])$OutputPackage
      import Integer
      if symbol? x and symbol? y
        and rank(symbol x)$SINFunctions < 0
          and rank(symbol y)$SINFunctions  < 0 then
            -- non-commutative symbols anti-commute
            if smaller?(y,x)$SINFunctions then
              --output("rewriteAntiCommutative: ",m(f(y,x))::OutputForm)$OutputPackage
              return m(f(y,x))
            if not smaller?(x,y) then return 0
      -- everythning else commutes
      if smaller?(y,x)$SINFunctions then return f(y,x)
      "failed"

)abbrev category ASSAX AssociativeAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Associative
AssociativeAxiom(): Category == Axiom with
    rewriteAssociative: (SIN->Maybe Pair SIN, (SIN,SIN)->SIN, SIN) -> Maybe SIN
  add
    rewriteAssociative(terms:SIN->Maybe Pair SIN, f:(SIN,SIN)->SIN, sin:SIN):Maybe(SIN) ==
      if _$testingSystem$Lisp then
        output("rewriteAssociative: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      -- to the right
      --if (t:=terms(x)) case Pair SIN then
      --  rin := f(t.left,f(t.right,y))
      -- to the left
      if (t:=terms(y)) case Pair SIN then
        rin := f(f(x,t.left),t.right)
      else
        return "failed"
      if _$testingSystem$Lisp then
        output("rewriteAssociative: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
        --if not smaller?(sin,rin)$SINFunctions then error "not smaller"
      return rin

)abbrev category ASSAXP AssociativeAxiomPlus
AssociativeAxiomPlus():Category == AssociativeAxiom
)abbrev category ASSAXT AssociativeAxiomTimes
AssociativeAxiomTimes():Category == AssociativeAxiom

)abbrev category CANAX CancelsAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Cancelling
CancelsAxiom(): Category == Axiom with
    rewriteCancels: SIN -> Maybe SIN
  add
    rewriteCancels(sin:SIN):Maybe SIN ==
      if _$testingSystem$Lisp then
        output("rewriteCancels: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      if integer? x and integer? y then
        rin := convert(integer(x)-integer(y))
      else
        if float? x and float? y then
          rin := convert(float(x)-float(y))
        else
          if x = y then
            rin := 0
          else
            return "failed"
      if _$testingSystem$Lisp then
        output("rewriteCancels: ",infix(message " --> ",coerce(sin)@OutputForm,coerce(rin)@OutputForm))$OutputPackage
        --if smaller?(sin,rin)$SINFunctions then error "not smaller"
      return rin

)abbrev category COMAX CommutativeAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Commutative
CommutativeAxiom(): Category == Axiom with
    rewriteCommutative: (SIN->Maybe Pair SIN,(SIN,SIN)->SIN, SIN) -> Maybe(SIN)
  add
    rewriteCommutative(terms:SIN->Maybe Pair SIN,f:(SIN,SIN)->SIN, sin:SIN): Maybe(SIN) ==
      if _$testingSystem$Lisp then
        output("rewriteCommutative: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      if smaller?(x,y)$SINFunctions then
        rin := f(y,x)
      else
        -- look on the left
        if % has AssociativeAxiom and (tx := terms x) case Pair SIN then
          if smaller?(tx.right,y) then
            rin := f(tx.left,f(y,tx.right))
          else
            -- look on the right
            if % has AssociativeAxiom and (ty := terms y) case Pair SIN then
              if smaller?(x,ty.left) then
                rin := f(f(ty.left,x),ty.right)
              else
                return "failed"
            else
              return "failed"
        else
          return "failed"
      if _$testingSystem$Lisp then
        output("rewriteCommutative: ",infix(message " --> ", message unparse sin,message unparse rin))$OutputPackage
        --if not smaller?(sin,rin)$SINFunctions then error "not smaller"
      return rin

)abbrev category COMAXP CommutativeAxiomPlus
CommutativeAxiomPlus():Category == CommutativeAxiom
)abbrev category COMAXT CommutativeAxiomTimes
CommutativeAxiomTimes():Category == CommutativeAxiom
)abbrev category COMAX2 CommutativeAxiomTimesTimes
CommutativeAxiomTimesTimes():Category == CommutativeAxiom
)abbrev category COMAX3 CommutativeAxiomJoin
CommutativeAxiomJoin():Category == CommutativeAxiom

)abbrev category DBLAX DoublesAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Doubling
DoublesAxiom(): Category == Axiom with
    rewriteDoubles: ((SIN,SIN)->SIN, SIN->Maybe Pair SIN, (SIN,SIN)->SIN, SIN->Maybe Pair SIN, SIN) -> Maybe SIN
  add
    rewriteDoubles( times:(SIN,SIN)->SIN, istimes:SIN->Maybe Pair SIN, plus:(SIN,SIN)->SIN, isplus:SIN->Maybe Pair SIN, sin:SIN ) : Maybe SIN ==
      x:=sin.2; y:=sin.3
      if _$testingSystem$Lisp then
        output("rewriteDoubles: ",message unparse sin)$OutputPackage
      -- constants
      if integer? x and integer? y then return convert(integer(x)+integer(y))
      if float? x and float? y then return convert(float(x)+float(y))
      -- x*n+x*m --> x*(n+m)
      if (tx:=istimes(x)) case "failed" or not integer? tx.right then tx := [x,1]$Pair(SIN)
      if (ty:=istimes(y)) case "failed" or not integer? ty.right then ty := [y,1]$Pair(SIN)
      if tx case Pair SIN and ty case Pair SIN and tx.left = ty.left then
        return times(tx.left,convert(integer(tx.right)+integer(ty.right)))
      -- look right
      if % has AssociativeAxiomTimes then
        -- (x+y)+y --> x+2*y
        if (t:=isplus(x)) case Pair SIN then
          r1:=rewriteDoubles(times,istimes,plus,isplus,convert [car sin,t.right,y])
          if r1 case SIN then return plus(t.left,r1)
      -- look left
      if % has AssociativeAxiomTimes then
        -- x+(x+y) --> 2*x+y
        if (t:=isplus(y)) case Pair SIN then
          l1:=rewriteDoubles(times,istimes,plus,isplus,convert [car sin,x,t.left])
          if l1 case SIN then return plus(l1,t.right)
      "failed"

)abbrev category DISAX DistributiveAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Distributive
DistributiveAxiom(): Category == Axiom with
    rewriteDistributive: (SIN->Maybe Pair SIN, (SIN,SIN)->SIN, (SIN,SIN)->SIN, SIN) -> Maybe SIN
  add
    rewriteDistributive(terms:SIN->Maybe Pair SIN, plus:(SIN,SIN)->SIN, times:(SIN,SIN)->SIN, sin:SIN): Maybe(SIN) ==
      x:=sin.2; y:=sin.3
      if _$testingSystem$Lisp then
        output("rewriteDistributive: ",message unparse sin)$OutputPackage
      rin:SIN
      if (t:=terms(x)) case Pair SIN then
        rin := plus(times(t.left,y),times(t.right,y))
      else
        if (t:=terms(y)) case Pair SIN then
          rin := plus(times(x,t.left),times(x,t.right))
        else
          return "failed"
      if _$testingSystem$Lisp then
        output("rewriteDistributive: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
        --if not smaller?(sin,rin)$SINFunctions then output("not smaller")$OutputPackage
      return rin

)abbrev category DIVAX DividesAxiom
Maybe(S) ==> Union(S,"failed")
applyIf(f,x) ==> if (%r:=x) case "failed" then "failed" else f(%r)
returnIf(x) ==> if not((%r:=x) case "failed") then return %r
orReturn(x) ==> if x case "failed" then return "failed"
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Divides
DividesAxiom(): Category == Axiom with
    rewriteDivides: (SIN, SIN) -> Maybe SIN
  add
    rewriteDivides(x:SIN, y:SIN): Maybe SIN ==
      if _$testingSystem$Lisp then
        output("rewriteDivides: ",paren [x::OutputForm,y::OutputForm])$OutputPackage
      if eq(y,0) then return "failed"
      if eq(x,0) then return 0
      if integer? x and integer? y then
        orReturn(r:=integer(x) exquo integer(y))
        return convert r
      if float? x and float? y then return convert(float(x)/float(y))
      if x = y then return 1
      "failed"

)abbrev category INVAX InverseAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Inverse
InverseAxiom(): Category == Axiom with
    rewriteInverseUnary: (SIN->SIN,SIN->Maybe Pair SIN,(SIN,SIN)->SIN,SIN) -> Maybe SIN
    rewriteRightInverse: (SIN->SIN,(SIN,SIN)->SIN,SIN)-> Maybe SIN
    rewriteLeftInverse: (SIN->SIN,(SIN,SIN)->SIN,SIN)-> Maybe SIN
  add
    rewriteInverseUnary(inv:SIN->SIN,terms:SIN->Maybe Pair SIN,f:(SIN,SIN)->SIN, x:SIN) ==
      if _$testingSystem$Lisp then
        output("rewriteInverseUnary: ",message unparse x)$OutputPackage
      -- involution?
      -- -(-x) --> x
      -- 1/(1/x) --> x
      if list? x and x = inv last destruct x then
        rin := last destruct x
      else
        return "failed"
      if _$testingSystem$Lisp then
        output("rewriteInverseUnary: ",infix(message " --> ",message unparse x,message unparse rin))$OutputPackage
      return rin
    rewriteRightInverse(inv:SIN->SIN,f:(SIN,SIN)->SIN,sin:SIN): Maybe SIN ==
      x:=sin.2; y:=sin.3
      if _$testingSystem$Lisp then
        output("rewriteRightInverse: ", message unparse sin)$OutputPackage
      -- inverse on the right
      -- x - (-y) --> x + y
      -- x + (-y) --> x - y
      -- x / (1/y) --> x * y
      -- x * (1/y) --> x / y
      if list? y and inv(y) = last destruct y then
        rin :=f(x,last destruct y)
      else
        return "failed"
      if _$testingSystem$Lisp then
        output("rewriteRightInverse: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
      return rin
    rewriteLeftInverse(inv:SIN->SIN,f:(SIN,SIN)->SIN,sin:SIN): Maybe SIN ==
      x:=sin.2; y:=sin.3
      if _$testingSystem$Lisp then
        output("rewriteLeftInverse: ", message unparse sin)$OutputPackage
      -- inverse on the left
      -- (-x) - y -->     -(x + y)   ??
      -- (-x) + y -->     -(x - y)   ??
      -- (1/x) / y -->    1/(x * y)
      -- (1/x) * y -->x   1/(x / y)
      if list? x and inv(x) = last destruct x then
        rin := inv f(last destruct x,y)
      else
        return "failed"
      if _$testingSystem$Lisp then
        output("rewriteLeftInverse: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
      return rin

)abbrev category LIDAX LeftIdentityAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
LeftIdentityAxiom(): Category == Axiom with
    rewriteLeftIdentity: (SIN,SIN)-> Maybe SIN
  add
    rewriteLeftIdentity(u:SIN,sin:SIN): Maybe SIN ==
      x:=sin.2; y:=sin.3
      if _$testingSystem$Lisp then
        output("rewriteLeftIdentity: ",message unparse sin)$OutputPackage
      if x=u then
        rin := y
      else return "failed"
      if _$testingSystem$Lisp then
        output("rewriteLeftIdentity: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
      return rin

)abbrev category RIDAX RightIdentityAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
RightIdentityAxiom(): Category == Axiom with
    rewriteRightIdentity: (SIN,SIN)-> Maybe SIN
  add
    rewriteRightIdentity(u:SIN,sin:SIN): Maybe SIN ==
      x:=sin.2; y:=sin.3
      if _$testingSystem$Lisp then
        output("rewriteRightIdentity: ",message unparse sin)$OutputPackage
      if y=u then
        rin := x
      else return "failed"
      if _$testingSystem$Lisp then
        output("rewriteRightIdentity: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
      return rin

)abbrev category IDAX IdentityAxiom
++ Identity
IdentityAxiom(): Category == Join(LeftIdentityAxiom,RightIdentityAxiom)

)abbrev category SQAX SquaresAxiom
Maybe(S) ==> Union(S,"failed")
SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Squares
SquaresAxiom(): Category == Axiom with
    rewriteSquares: ((SIN,SIN)->SIN, SIN->Maybe Pair SIN, (SIN,SIN)->SIN, SIN->Maybe Pair SIN, SIN) -> Maybe SIN
  add
    rewriteSquares( pow:(SIN,SIN)->SIN, ispower:SIN->Maybe Pair SIN, times:(SIN,SIN)->SIN, istimes:SIN->Maybe Pair SIN, sin:SIN ) : Maybe SIN ==
      x:=sin.2; y:=sin.3
      if _$testingSystem$Lisp then
        output("rewriteSquares: ",message unparse sin)$OutputPackage
      -- constants
      if integer? x and integer? y then return convert(integer(x)*integer(y))
      if float? x and float? y then return convert(float(x)*float(y))
      -- x^n*x^m --> x^(n+m)
      if (tx:=ispower(x)) case "failed" or not integer? tx.right then tx := [x,1]$Pair(SIN)
      if (ty:=ispower(y)) case "failed" or not integer? ty.right then ty := [y,1]$Pair(SIN)
      if tx case Pair SIN and ty case Pair SIN and ty.left = tx.left then
        return pow(tx.left,convert(integer(tx.right)+integer(ty.right)))
      -- look right
      if % has AssociativeAxiomTimes then
        -- (x*y)*y --> x*y^2
        if (t:=istimes(x)) case Pair SIN then
          r1:=rewriteSquares(pow,ispower,times,istimes,convert [car sin, t.right,y])
          if r1 case SIN then return times(t.left,r1)
      -- look left
      if % has AssociativeAxiomTimes then
        -- x*(x*y) --> x^2*y
        if (t:=istimes(y)) case Pair SIN then
          l1:=rewriteSquares(pow,ispower,times,istimes,convert [car sin, x,t.left])
          if l1 case SIN then return times(l1,t.right)
      "failed"

)abbrev domain SYMB Symbolic
-- Type safe representation
rep(x) ==> x @ % pretend Rep
per(x) ==> x @ Rep pretend %
-- Applicative-style macros
Maybe(S) ==> Union(S,"failed")
applyIf(f,x) ==> if (%r:=x) case "failed" then "failed" else f(%r)
returnIf(x) ==> if not((%r:=x) case "failed") then return %r
orReturn(x) ==> if x case "failed" then return "failed"

SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)
++ Unevaluated mathematical expressions
++ Author: Bill Page
++ Date Created: 12 February 2017
++ Description:
++ Symbolic is a domain that represents expressions involving symbolic
++ operations. These expressions remain unevaluated and are displayed as
++ entered unless otherwise specified. Rewrite rules implementing various
++ common axioms can be specified that will be automatically applied when
++ expressions are evaluated by the interpreter. Full simplification of
++ expressions if/when desired is performed by means of interpretation in
++ the Expression domain.
++ Keywords: expression, evaluation, operator, function.
Symbolic(R:Join(Comparable,ConvertibleTo SIN), AxiomList:Type):SymbolicCategory(R) == Implementation where
  --F ==> Expression R
  K   ==> Kernel %
  KF  ==> Kernel F
  SMP  ==> SparseMultivariatePolynomial(R, K)
  --AF  ==> AlgebraicFunction(R, F)
  --EF  ==> ElementaryFunction(R, F)
  CF  ==> CombinatorialFunction(R, Expression R)
  --LF  ==> LiouvillianFunction(R, F)
  --AN  ==> AlgebraicNumber
  --KAN ==> Kernel AN
  --ESD ==> ExpressionSpace_&(F)
  --FSD ==> FunctionSpace_&(F, R)

  Implementation ==> add
    Rep := SIN
    --rep(x:%):Rep == x pretend Rep
    --per(x:Rep):% == x pretend %
    smaller?(x:%,y:%):Boolean == smaller?(rep x, rep y)$SINFunctions

    belong? op == true
    if R has AbelianSemiGroup then
      0:% == per 0$Rep
      zero? x == x = 0
    if R has SemiGroup then
      1:% == per 1$Rep
      one? x  == x = 1

    hash(x:%):SingleInteger == hash(rep x)$SIN
    equal?(eq:Equation %):Boolean == not smaller?(lhs eq,rhs eq) and not smaller?(rhs eq,lhs eq)
    (x:% = y:%):Boolean == not smaller?(x,y) and not smaller?(y,x)

    subst(x:%,e:Equation %):% == per SUBST(rep rhs e,rep lhs e,rep x)$Lisp
    subst(x:%,ks:List Kernel %, vs:List %) ==
      if #ks > 1 then return subst(subst(x,equation(first(ks)::%,first(vs))),rest ks, rest vs)
      else return subst(x,equation(first(ks)::%,first(vs)))
    subst(x:%, es:List Equation %):% ==
      if #es > 1 then return subst(subst(x, first es),rest es)
      else subst(x, first es)
    --
    --if R has ConvertibleTo SIN then
    eval(x:%):% ==
      --output("eval 0:", x::OutputForm)$OutputPackage
      interpret(convert(x)@SIN)$InputFormFunctions1(%)
    eval(x:%,k:Kernel(%),s:%):% ==
      --output("eval 1:", paren [x::OutputForm, k::OutputForm, s::OutputForm])$OutputPackage
      eval subst(x,[k],[s])
    eval(x:%,ks:List Kernel %, vs:List %) ==
      --output("eval 2:", paren [x::OutputForm, ks::OutputForm, vs::OutputForm])$OutputPackage
      r:=x
      -- Use temporary symbols in case of parallel substitutions
      ts:List Kernel % := [kernel(new()$Symbol) for k in ks]
      for k in ks for t in ts repeat
        r:=eval(r,k,coerce t)
      for t in ts for v in vs repeat
        r:=eval(r,t,v)
      return r
    eval(x:%,a:%,b:%):% ==
      --output("eval 3:", paren [x::OutputForm, a::OutputForm, b::OutputForm])$OutputPackage
      eval(x, retract a, b)
    eval(x:%,e:Equation %):% == eval(x,lhs e,rhs e)
    --
    -- need to handle subscripted Symbol
    retractIfCan(x:%):Maybe(Kernel %) ==
      --output("retractIfCan Kernel: ",x::OutputForm)$OutputPackage
      if atom? rep x and symbol? rep x then return kernel symbol rep x
      if list? rep x and symbol? car rep x then
        if list? cdr rep x then
          s := symbol car rep x
          -- Why not '_- ??
          if not member?(s,['_+,'_*,'_/])$List(Symbol) then
            k:Kernel(%) := kernel(operator(s)$CommonOperators,
              destruct cdr rep x, #cdr(rep x)::NonNegativeInteger)
            return k
          else
            return "failed"
        else
          return "failed"
      else
        return "failed"
    retractIfCan(x:%):Maybe(R) ==
      --output("retractIfCan R: ",x::OutputForm)$OutputPackage
      if list? rep x and # cdr rep x = 0 then error "stop"
      if R is Integer then
        if integer? rep x then return (integer rep x) pretend R
      if R is DoubleFloat then
        if float? rep x then return (float rep x) pretend R
      if R is Symbol then
        if symbol? rep x then return (symbol rep x) pretend R
      --
      return "failed"
    retractIfCan(x:%):Maybe(Symbol) ==
      --output("retractIfCan Symbol: ",x::OutputForm)$OutputPackage
      if symbol? rep x then symbol rep x
      else "failed"
    retract(x:%):Symbol ==
      --output("retract Symbol: ",x::OutputForm)$OutputPackage
      s:=retractIfCan(x)@Maybe(Symbol)
      if s case Symbol then return s
      error "not a Symbol"
    --
    isPlus2(x:SIN):Maybe(Pair SIN) ==
      list? x and # cdr x = 2 and symbol? car x and symbol car x = '_+ => [car cdr x, car cdr cdr x]
      "failed"
    isMinus2(x:SIN):Maybe(Pair SIN) ==
      list? x and # cdr x = 2 and symbol? car x and symbol car x = '_- => [car cdr x, car cdr cdr x]
      "failed"
    isTimes2(x:SIN):Maybe(Pair SIN) ==
      list? x and # cdr x = 2 and symbol? car x and symbol car x = '_* => [car cdr x, car cdr cdr x]
      "failed"
    isDivide2(x:SIN):Maybe(Pair SIN) ==
      list? x and # cdr x = 2 and symbol? car x and symbol car x = '_/ => [car cdr x, car cdr cdr x]
      "failed"
    if R has IntegralDomain then
      -- Symbolic is syntactical!
      numerator(x:%):% ==
        r := isDivide2 rep x
        if r case Pair SIN then
          return per r.left
        else
          return x
      denominator(x:%):% ==
        r := isDivide2 rep x
        if r case Pair SIN then
          return per r.right
        else
          return 1
      makeKernel(x:%):Kernel % ==
        --output("makeKernel: ",x::OutputForm)$OutputPackage
        if symbol? rep x then return kernel symbol rep x
        k:Maybe(Kernel %):=retractIfCan(x)
        if k case Kernel % then
          return k
        else
          -- We must wrap up this term in a paren box for SMP.
          return coerce kernel(operator('%box)$CommonOperators,[x],1)$K
      smpTerm(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        --output("smpTerm: ",x::OutputForm)$OutputPackage
        t:=isTimes x
        if t case List % then
          return reduce("*",[smpTerm(i) for i in t])
        t2:=isPower x
        if t2 case Record(val:%,exponent:Integer) then
          if t2.exponent > 0 then
            return smpTerm(t2.val)^(t2.exponent::NonNegativeInteger)
        -- this test is not quite adequate
        if R is Integer and integer? rep x then
          return coerce integer rep x
        else
          return coerce makeKernel(x)
      numer(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        --output("numer: ",x::OutputForm)$OutputPackage
        r:=numerator(x)
        s:=isPlus r
        if s case List % then
          return reduce("+",[smpTerm(i) for i in s])
        else
          return smpTerm(r)
      denom(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        --output("denom: ",x::OutputForm)$OutputPackage
        r:=denominator(x)
        s:=isPlus r
        if s case List % then
          return reduce("+",[smpTerm(i) for i in s])
        else
          return smpTerm(r)

      (x:SMP / y:SMP):% == coerce(x) / coerce(y)
      isPlus(x:%):Maybe(List %) ==
        r := isPlus2 rep x
        if r case Pair SIN then
          r1:=isPlus per(r.left)
          r2:=isPlus per(r.right)
          if r1 case List % then
            if r2 case List % then
              concat(r1,r2)
            else
              concat(r1, [per(r.right)])
          else
            if r2 case List % then
              concat([per(r.left)],r2)
            else
              [per(r.left),per(r.right)]
        else
          "failed"

      isMinus(x:%):Maybe(List %) ==
        r := isMinus2 rep x
        if r case Pair SIN then
          r1:=isMinus per(r.left)
          r2:=isMinus per(r.right)
          if r1 case List % then
            if r2 case List % then
              concat(r1,r2)
            else
              concat(r1, [per(r.right)])
          else
            if r2 case List % then
              concat([per(r.left)],r2)
            else
              [per(r.left),per(r.right)]
        else
          "failed"

      factorials(x:%):%           == coerce factorials(coerce x)$CF
      factorials(x:%, n:Symbol):% == coerce factorials(coerce x, n)$CF

      if SMP has PolynomialFactorizationExplicit then
        factor(x:%):% ==
          (factor(numer x)::OutputForm pretend SIN /
            factor(denom x)::OutputForm pretend SIN)$SIN

      expand(x:%):% ==
        n := isPlus numerator(x)
        if n case List % then
          d:% := denominator(x)
          if d=1 then return reduce("+",[s for s in n])
          return reduce("+",[s/d for s in n])
        else
          return x
      --
      if R has ConvertibleTo SIN then
        coerce(x:SMP):% == per convert(x)$SMP
        coerce(x:Polynomial R):% == per convert(x)$Polynomial(R)
        coerce(x:Fraction R):% == per convert(x)$Fraction(R)
      if R has RetractableTo Integer or R has RetractableTo Fraction Integer then
        retractIfCan(x:%):Maybe(Fraction Integer) ==
          r:Maybe(R):=retractIfCan(x)
          if R has RetractableTo Fraction Integer then
            return retractIfCan(r::R)@Maybe(Fraction Integer)
          if R has RetractableTo Integer then
            r2:Maybe(Integer):=retractIfCan(r::R)
            if r2 case Integer then return r2::Integer::Fraction Integer
          return "failed"
      if R has PatternMatchable Integer then
        patternMatch(x : %, p : Pattern Integer, l : PatternMatchResult(Integer, %)) ==
          --output("patternMatch: ",paren [x::OutputForm,p::OutputForm,l::OutputForm])$OutputPackage
          patternMatch(x, p, l)$PatternMatchFunctionSpace(Integer, R, %)

      if R has PatternMatchable Float then
        patternMatch(x : %, p : Pattern Float, l : PatternMatchResult(Float, %)) ==
          patternMatch(x, p, l)$PatternMatchFunctionSpace(Float, R, %)

    if R has SemiGroup then
      isTimes(x:%):Maybe(List %) ==
        r := isTimes2 rep x
        if r case Pair SIN then
          r1:=isTimes per(r.left)
          r2:=isTimes per(r.right)
          if r1 case List % then
            if r2 case List % then
              concat(r1,r2)
            else
              concat(r1, per(r.right))
          else
            if r2 case List % then
              concat(per(r.left),r2)
            else
              [per(r.left),per(r.right)]
        else
          "failed"

    coerce(x:Pi):% == per convert(x)$Pi
    coerce(x:Symbol):% == per convert(x)$Symbol
    coerce(k:Kernel %):% == per convert(k)@Rep

    coerceOutputForm1:(Rep,Boolean)->OutputForm
    coerceOutputForm(x:Rep):OutputForm ==coerceOutputForm1(x,false)
    coerceOutputForm1(x:Rep,topLevel:Boolean):OutputForm ==
      if null? x then return empty()$OutputForm
      if atom? x then return (x pretend OutputForm)
      if list? x and symbol? car x then
        s := symbol car x
        -- scripted?
        if #string(s)>2 and ord string(s).1 = 42 and digit? string(s).2 then
          return coerce(x pretend Symbol)
        if s='%paren then
          return paren coerceOutputForm car cdr x
        if s='%box then
          -- make box invisible (for now)
          return coerceOutputForm car cdr x
          return bracket coerceOutputForm car cdr x
        if s='float then
          return interpret(x)$InputFormFunctions1(Float)::OutputForm
        if s='factorial then
          if list? car(cdr x) then
            return postfix(outputForm '_!, paren coerceOutputForm car cdr x)
          else
            return postfix(outputForm '_!, coerceOutputForm car cdr x)
        if s='sum or s='summation then
            return sum(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='product then
            return prod(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='binomial then
            return binomial(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='sqrt then
            return root coerceOutputForm car cdr x
        if s='nthRoot then
            return root(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='_^ and car cdr cdr x = convert(1/2) then
            return root(coerceOutputForm car cdr x)
        if s='exp and car(cdr x)=1 then return outputForm '%e
        if member?(s,['_+,'_-,'_*,'_/,'_^])$List(Symbol) and #cdr(x)>1 then
          if s='_/ then -- assume )set output fraction vertical (should check flag?)
            return infix(outputForm s, [coerceOutputForm1(i,true) for i in destruct cdr x])
          else if AxiomList has AssociativeAxiom or topLevel then
            return infix(outputForm s, [coerceOutputForm(i) for i in destruct cdr x])
          else -- ( ) required if non-associative
            return paren infix(outputForm s, [coerceOutputForm(i) for i in destruct cdr x])
        else
          if list? car(cdr x) or s ~= '_- then
            return prefix(outputForm s,
              [coerceOutputForm(i) for i in destruct cdr x])
          else
            return hconcat([outputForm s, hspace(1), coerceOutputForm car cdr x])
      else
        return hconcat(message("what is:")$OutputForm,x pretend OutputForm)
    coerce(x:%):OutputForm == coerceOutputForm1(rep x,true)

    -- +0 is a hack to avoid premature conversion (do we need it?)
    --hack(x:%):Rep == binary(convert('_+),[rep x,0$Rep])
    -- better hack?
    hack(x:%):Rep == convert([convert 'coerce,rep x])

    coerce(x:%):Expression(R) ==
      --output("coerce: Expression(R)",x::OutputForm)$OutputPackage
      v:List Symbol := variables x
      if #v = 0 then return interpret(coerceToType(rep x)$InputFormFunctions1(Expression(R)))$InputFormFunctions1(Expression(R))
      -- we need to substitute variables with unknown modes
      s:List Symbol := [new()$Symbol for vi in v]
      ks:List Equation % := [equation(coerce(vi)$%, coerce(si)$%) for vi in v for si in s]
      sk:List Equation Expression(R) := [equation(coerce(si)$Expression(R), coerce(vi)$Expression(R)) for vi in v for si in s]
      return subst(interpret(coerceToType(rep subst(x,ks))$InputFormFunctions1(Expression(R)))$InputFormFunctions1(Expression(R)),sk)
    if R has ConvertibleTo SIN then
      coerce(x:Expression(R)):% == per convert(x)$Expression(R)
      coerce(x:R):% == per convert(x)$R
    convert(x:%):SIN == rep x
    coerce(x:SIN):% == per x
    --
    factorial(x:%):%          == per convert([convert('factorial)@SIN,rep x])
    binomial(n:%, m:%):%      == binary(convert('binomial),[n::Rep,m::Rep])$SIN
    permutation(n:%, m:%):%   == binary(convert('permutation),[n::Rep,m::Rep])$SIN
    --
    sum(x : %, n : Symbol):%           == per binary(convert('sum),[rep x,convert(n)@SIN])$SIN
    sum(x : %, s : SegmentBinding %):% == per binary(convert('sum),[rep x,convert(s)@SIN])$SIN
    summation(x : %, n : Symbol):%           == per binary(convert('summation),[rep x,convert(n)@SIN])$SIN
    summation(x : %, s : SegmentBinding %):% == per binary(convert('summation),[rep x,convert(s)@SIN])$SIN
    product(x : %, n : Symbol):%             == per binary(convert('product),[rep x,convert(n)@SIN])$SIN
    product(x : %, s : SegmentBinding %):%   == per binary(convert('product),[rep x,convert(s)@SIN])$SIN

    -- We don't want the InputForm auto-simplifications because we may or
    -- may not be doing our own simplifications.
    nthRoot2(x:Rep,n:Rep):Rep ==
      if n=1 then return x
      return binary(convert('nthRoot),[x,n])$SIN
    nthRoot(x:%, n:Integer):% == per nthRoot2(rep x,n::Rep)
    nthRoot(x:%, n:%):% == per nthRoot2(rep x,n::Rep)
    --
    power: (Rep,Rep) -> Rep
    power(x:Rep,y:Rep):Rep == binary(convert('_^),[x,y])$SIN
    (x:% ^ y:%):% == per power(rep x,rep y)
    (x:% ^ y:PositiveInteger):% == expt(x, y)$RepeatedSquaring(%)
    (x:% ^ y:NonNegativeInteger):% ==
      if y = 0 then x^0
      else x ^ y::PositiveInteger
    (x:% ^ y:Integer):% ==
      if y < 0 then 1/(x ^ (-y)::PositiveInteger)
      else x ^ y::NonNegativeInteger
    (x:% ^ y:Fraction Integer):% == nthRoot(x,denom(y))^numer(y)
    isPower1(x:SIN):Maybe(Pair SIN) ==
      list? x and symbol? car x and symbol car x = '_^ => [car cdr x, car cdr cdr x]
      "failed"
    isPower(x:%):Maybe(Record(val:%,exponent:Integer)) ==
      r:=isPower1(rep x)
      if r case Pair SIN then
        if integer?(r.right) then
          return [per r.left,integer(r.right)]
      "failed"
    --
    plus: (Rep,Rep) -> Rep
    minus: (Rep,Rep) -> Rep
    minus1: Rep -> Rep
    divide2: (Rep,Rep) -> Rep
    divide1 : Rep -> Rep

    times(x:Rep,y:Rep):Rep ==
      sin:SIN:=binary(convert('_*),[x,y])$SIN
      if _$testingSystem$Lisp then
        output("times: ",message unparse sin)$OutputPackage
      if AxiomList has DistributiveAxiom then
        returnIf rewriteDistributive(isPlus2,plus,times,sin)
        returnIf rewriteDistributive(isMinus2,minus,times,sin)
      if AxiomList has AssociativeAxiomTimes then
        returnIf rewriteAssociative(isTimes2,times,sin)
      if AxiomList has LeftIdentityAxiom then
        returnIf rewriteLeftIdentity(1,sin)
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteRightIdentity(1,sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteRightInverse(divide1,divide2,sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteLeftInverse(divide1,divide2,sin)
      if AxiomList has AntiCommutativeAxiom then
        returnIf rewriteAntiCommutative(minus1,times,x,y)
      if AxiomList has CommutativeAxiomTimes then
        returnIf rewriteCommutative(isTimes2,times,sin)
      if AxiomList has SquaresAxiom then
        returnIf rewriteSquares(power,isPower1,times,isTimes2,sin)
      return sin
    (x:% * y:%):% == per times(rep x,rep y)
    --
    (x:PositiveInteger * y:%):% == double(x,y)$RepeatedDoubling(%)
    (x:NonNegativeInteger * y:%):% ==
      if x=0 then 0*y
      else x::PositiveInteger * y
    (x:Integer * y:%):% ==
      if x < 0 then
        (-x)::PositiveInteger * y
      else
        x::NonNegativeInteger * y
    --
    plus(x:Rep,y:Rep):Rep ==
      sin:SIN:=binary(convert('_+),[x,y])$SIN
      if _$testingSystem$Lisp then
        output("plus: ",message unparse sin)$OutputPackage
      if AxiomList has AssociativeAxiomPlus then
        returnIf rewriteAssociative(isPlus2,plus,sin)
      if AxiomList has LeftIdentityAxiom then
        returnIf rewriteLeftIdentity(0,sin)
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteRightIdentity(0,sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteRightInverse(minus1,minus,sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteLeftInverse(minus1,minus,sin)
      if AxiomList has CommutativeAxiomPlus then
        returnIf rewriteCommutative(isPlus2,plus,sin)
      if AxiomList has DoublesAxiom then
        returnIf rewriteDoubles(times,isTimes2,plus,isPlus2,sin)
      return sin
    (x:% + y:%):% == per plus(rep x,rep y)

    minus(x:Rep,y:Rep):Rep ==
      sin:SIN := binary(convert('_-),[x,y])$SIN
      if _$testingSystem$Lisp then
        output("minus: ",message unparse sin)$OutputPackage
      if AxiomList has LeftIdentityAxiom and x = 0$Rep then
        return minus1(y)
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteRightIdentity(0,sin)
      if AxiomList has CancelsAxiom then
        returnIf rewriteCancels(sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteRightInverse(minus1,plus,sin)
      return sin
    (x:% - y:%):% == per minus(rep x,rep y)

    minus1(x:Rep):Rep ==
      if _$testingSystem$Lisp then
        output("minus1: ",coerce(x)@OutputForm)$OutputPackage
      if AxiomList has InverseAxiom then
        returnIf rewriteInverseUnary(minus1,isMinus2,minus,x)
      if (t:=isMinus2(x)) case Pair SIN then return minus(t.right,t.left)
      if (t:=isPlus2(x)) case Pair SIN then return plus(minus1 t.left,minus1 t.right)
      convert([convert('_-)@SIN,x])
    _-(x:%):% == per minus1 rep x

    divide2(x:Rep,y:Rep):Rep ==
      sin:SIN:=binary(convert('_/),[x,y])
      if _$testingSystem$Lisp then
        output("divide: ",message unparse sin)$OutputPackage
      if x = 1$Rep then return divide1(y)
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteRightIdentity(1,sin)
      if AxiomList has DividesAxiom then
        returnIf rewriteDivides(x,y)
      if AxiomList has InverseAxiom then
        returnIf rewriteRightInverse(divide1,times,sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteLeftInverse(divide1,times,sin)
      return sin
    (x:% / y:%):% == per divide2(rep x,rep y)

    divide1(x:Rep):Rep ==
      if _$testingSystem$Lisp then
        output("divide1: ",coerce(x)@OutputForm)$OutputPackage
      if AxiomList has InverseAxiom then
        returnIf rewriteInverseUnary(divide1,isDivide2,divide2,x)
      if (t:=isDivide2(x)) case Pair SIN then return divide2(t.right,t.left)
      binary(convert('_/),[1$SIN,x])

    inv(x:%):% ==
      if _$testingSystem$Lisp then
        output("inv: ",x::OutputForm)$OutputPackage
      per divide1 rep x

    elt(f:BasicOperator,x:List %):% ==
      --output("elt: ", paren [f::OutputForm,x::OutputForm])$OutputPackage
      if not property(f,'%symbol) case "failed" then
        return per convert name f
      else
        -- Should we actually evaluate the operator??
        return per convert(concat(convert(name f)@SIN,[rep i for i in x]))

    -- Elementary Functions
    acos(x:%):% == per convert([convert('acos)@SIN,rep x])
    acosh(x:%):% == per convert([convert('acosh)@SIN,rep x])
    acot(x:%):% == per convert([convert('acot)@SIN,rep x])
    acoth(x:%):% == per convert([convert('acoth)@SIN,rep x])
    acsc(x:%):% == per convert([convert('acsc)@SIN,rep x])
    acsch(x:%):% == per convert([convert('acsch)@SIN,rep x])
    asec(x:%):% == per convert([convert('asec)@SIN,rep x])
    asech(x:%):% == per convert([convert('asech)@SIN,rep x])
    asin(x:%):% == per convert([convert('asin)@SIN,rep x])
    asinh(x:%):% == per convert([convert('asinh)@SIN,rep x])
    atan(x:%):% == per convert([convert('atan)@SIN,rep x])
    atanh(x:%):% == per convert([convert('atanh)@SIN,rep x])
    cos(x:%):% == per convert([convert('cos)@SIN,rep x])
    cosh(x:%):% == per convert([convert('cosh)@SIN,rep x])
    cot(x:%):% == per convert([convert('cot)@SIN,rep x])
    coth(x:%):% == per convert([convert('coth)@SIN,rep x])
    csc(x:%):% == per convert([convert('csc)@SIN,rep x])
    csch(x:%):% == per convert([convert('csch)@SIN,rep x])
    exp(x:%):% == per convert([convert('exp)@SIN,rep x])
    log(x:%):% == per convert([convert('log)@SIN,rep x])
    pi():% == per convert([convert('pi)@SIN])
    sec(x:%):% == per convert([convert('sec)@SIN,rep x])
    sech(x:%):% == per convert([convert('sech)@SIN,rep x])
    sin(x:%):% == per convert([convert('sin)@SIN,rep x])
    sinh(x:%):% == per convert([convert('sinh)@SIN,rep x])
    sqrt(x:%):% == per convert([convert('sqrt)@SIN,rep x])
    tan(x:%):% == per convert([convert('tan)@SIN,rep x])
    tanh(x:%):% == per convert([convert('tanh)@SIN,rep x])
    --
    retract(x:%):R == retract(coerce x)$Expression(R)

    variables1(x:Rep):Set Symbol ==
      if null? x then return empty()
      if atom? x and symbol? x then return set [symbol x]
      if list? x and symbol? car x then
        if list? cdr x then
          return reduce("union", [variables1(i) for i in destruct cdr x],empty())
        else
          return variables1 car cdr x
      return empty()
    variables(x:%):List Symbol == members variables1(rep x)

    -- still need to handle non symbols and scripted symbols
    kernels1(x:Rep):Set Kernel % ==
      if null? x then return empty()
      if atom? x and symbol? x then return set [kernel symbol x]
      if list? x and symbol? car x then
          if list? cdr x then
            s := symbol car x
            if member?(s,['_+,'_-,'_*,'_/])$List(Symbol) then
              r:Set Kernel % := reduce("union",
                [kernels1(i) for i in destruct cdr x])
              return r
            else
              k:Kernel(%) := kernel(operator(s)$CommonOperators,
                destruct cdr x, #cdr(x)::NonNegativeInteger)
              return set [k]
          else
            return kernels1 car cdr x
      return empty()
    kernels(x:%):List Kernel % == members kernels1(rep x)

    if Expression(R) has TranscendentalFunctionCategory and R has GcdDomain then
      simplify(x:%):% ==
        coerce(simplify(coerce x)$TranscendentalManipulations(R,Expression R))
    convert(eq:Equation %): Equation SIN == equation(convert lhs eq, convert rhs eq)
    convert(eq:Equation SIN): Equation % == equation(convert lhs eq, convert rhs eq)

)abbrev domain ALT AntiCommutative
AntiCommutative():AntiCommutativeAxiom == add
  x:Symbolic(Integer,%):=coerce 'x
  y:Symbolic(Integer,%):=coerce 'y
  z:Symbolic(Integer,%):=coerce 'z
  assert("anticommutative *",y*x = -(x*y))

)abbrev domain ASSOCP AssociativePlus
AssociativePlus():AssociativeAxiomPlus == add
  x:Symbolic(Integer,%):=coerce 'x
  y:Symbolic(Integer,%):=coerce 'y
  z:Symbolic(Integer,%):=coerce 'z
  assert("associative +", x+(y+z) = (x+y)+z )

)abbrev domain ASSOCT AssociativeTimes
AssociativeTimes():AssociativeAxiomTimes == add
  x:Symbolic(Integer,%):=coerce 'x
  y:Symbolic(Integer,%):=coerce 'y
  z:Symbolic(Integer,%):=coerce 'z
  assert("associative *",x*(y*z)=(x*y)*z)

)abbrev domain CAN Cancels
Cancels():CancelsAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("cancels -",x-x = 0)

)abbrev domain COMMUTP CommutativePlus
CommutativePlus():CommutativeAxiomPlus == add
  x:Symbolic(Integer,%) := coerce 'x
  y:Symbolic(Integer,%) := coerce 'y
  assert("commutative +",x+y = y+x)

)abbrev domain COMMUTT CommutativeTimes
CommutativeTimes():CommutativeAxiomTimes == add
  x:Symbolic(Integer,%) := coerce 'x
  y:Symbolic(Integer,%) := coerce 'y
  assert("commutative *",x*y = y*x)

)abbrev domain DBL Doubles
Doubles():DoublesAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("doubles +",x+x = 2*x )

)abbrev domain DIS Distributive
Distributive():DistributiveAxiom == add
    x:Symbolic(Integer,%) := coerce 'x
    y:Symbolic(Integer,%) := coerce 'y
    z:Symbolic(Integer,%) := coerce 'z
    assert("distributive left +", x*(y+z)=(x*y)+(x*z) )
    assert("distributive left -", x*(y-z)=(x*y)-(x*z) )
    assert("distributive right +", (y+z)*x=(y*x)+(z*x) )
    assert("distributive right -", (y-z)*x=(y*x)-(z*x) )

)abbrev domain DIV Divides
Divides():DividesAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("divides",x/x = 1)

-- join(Inverse, Cancels) --> Identity
-- So who needs inverse?
)abbrev domain LID LeftIdentity
LeftIdentity():LeftIdentityAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("LeftIdentity +", 0+x = x )
  assert("LeftIdentity *", 1*x = x )

)abbrev domain RID RightIdentity
RightIdentity():RightIdentityAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("RightIdentity +", x+0 = x )
  assert("RightIdentity *", x*1 = x )
  assert("RightIdentity -", x-0 = x )
  assert("RightIdentity /", x/1 = x )

)abbrev domain INV Inverse
Inverse():InverseAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  y:Symbolic(Integer,%) := coerce 'y
  assert("inverse inverse -",-(-x) = x)
  assert("inverse inverse /",1/(1/x) = x)
  -- left
  assert("LeftInverse +", (-x) + y = -(x - y) )
  assert("LeftInverse *", (1/x) * y = 1/(x * (1/y)) )  -- y ~= 0
  assert("LeftInverse /", (1/x) / y = 1/(x * y) )
  -- right
  assert("RightInverse +", x + (-y) = x - y )
  assert("RightInverse -", x - (-y) = x + y )
  assert("RightInverse *", x * (1/y) = x / y )
  assert("RightInverse /", x / (1/y) = x * y )  -- x ~= 0

)abbrev domain SQ Squares
Squares():SquaresAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("squares *", x*x = x^2 )

)abbrev domain JOIN join
++ Conjunction of rules
join(A:Axiom,B:Axiom):Axiom with
    if A has CommutativeAxiomPlus then CommutativeAxiomPlus
    if B has CommutativeAxiomPlus then CommutativeAxiomPlus
    if A has CommutativeAxiomTimes then CommutativeAxiomTimes
    if B has CommutativeAxiomTimes then CommutativeAxiomTimes
    if A has AntiCommutativeAxiom then AntiCommutativeAxiom
    if B has AntiCommutativeAxiom then AntiCommutativeAxiom
    if A has DistributiveAxiom then DistributiveAxiom
    if B has DistributiveAxiom then DistributiveAxiom
    if A has AssociativeAxiom then AssociativeAxiom
    if B has AssociativeAxiom then AssociativeAxiom
    if A has AssociativeAxiomPlus then AssociativeAxiomPlus
    if B has AssociativeAxiomPlus then AssociativeAxiomPlus
    if A has AssociativeAxiomTimes then AssociativeAxiomTimes
    if B has AssociativeAxiomTimes then AssociativeAxiomTimes
    if A has IdentityAxiom then IdentityAxiom
    if B has IdentityAxiom then IdentityAxiom
    if A has RightIdentityAxiom then RightIdentityAxiom
    if B has RightIdentityAxiom then RightIdentityAxiom
    if A has LeftIdentityAxiom then LeftIdentityAxiom
    if B has LeftIdentityAxiom then LeftIdentityAxiom
    if A has InverseAxiom then InverseAxiom
    if B has InverseAxiom then InverseAxiom
    if A has DoublesAxiom then DoublesAxiom
    if B has DoublesAxiom then DoublesAxiom
    if A has CancelsAxiom then CancelsAxiom
    if B has CancelsAxiom then CancelsAxiom
    if A has SquaresAxiom then SquaresAxiom
    if B has SquaresAxiom then SquaresAxiom
    if A has DividesAxiom then DividesAxiom
    if B has DividesAxiom then DividesAxiom
  == add
    x:Symbolic(Integer,%) := coerce 'x
    y:Symbolic(Integer,%) := coerce 'y
    z:Symbolic(Integer,%) := coerce 'z

    if % has CommutativeAxiomTimes and % has AssociativeAxiomTimes then
      assert("commutative-associative *",z*(x*y) = (x*z)*y )

)abbrev domain ASSOC Associative
Associative():AssociativeAxiom == join(AssociativePlus, AssociativeTimes)

)abbrev domain COMMUT Commutative
Commutative():CommutativeAxiom == join(CommutativePlus, CommutativeTimes)

)abbrev domain ID Identities
Identities():IdentityAxiom == join(LeftIdentity, RightIdentity)

)abbrev domain SEXPR SymbolicExpression
SIN ==> InputForm
++ Description:
++ SymbolicExpression is a Symbolic domain with automatic rewrite rules that
++ approximate Expression itself.
SymbolicExpression(R:Join(Comparable,ConvertibleTo SIN)) : SymbolicCategory(R) == Implementation where
  --F ==> Expression R
  Implementation ==> Symbolic(R, _
    join(join(join(join(join(join(join(join(join(join( _
    Squares, Inverse), Identities), _
    Doubles), Divides), Distributive),  _
    CommutativePlus), CommutativeTimes), Cancels),  _
    AssociativePlus), AssociativeTimes)) add
    -- use equality from Expression(R)
    (x:% = y:%):Boolean ==
      --output("=",paren [x::OutputForm,y::OutputForm])$OutputPackage
      coerce(x)@Expression(R) = coerce(y)@Expression(R)

)abbrev package SYMPKG1 SymbolicFunctions1
SIN ==> InputForm
++ Converting one Symbolic expression into another
SymbolicFunctions1(R: Join(Comparable,ConvertibleTo SIN), A:SymbolicCategory R,
  S: Join(Comparable,ConvertibleTo SIN), B:SymbolicCategory S): with
    convert: B -> A
  == add
    -- +0 is a hack to avoid premature conversion
    --hack(x:B):SIN == binary(convert('_+),[convert x,0::SIN])
    convert(x:B):A ==
      v:List Symbol := variables(x)
      if #v = 0 then return interpret(coerceToType(convert x)$InputFormFunctions1(A))$InputFormFunctions1(A)
      -- we need to substitute variables with unknown modes
      s:List Symbol := [new()$Symbol for vi in v]
      ks:List Equation B := [equation(coerce(vi)$B, coerce(si)$B) for vi in v for si in s]
      sk:List Equation A := [equation(coerce(si)$A, coerce(vi)$A) for vi in v for si in s]
      return subst(interpret(coerceToType(convert subst(x,ks))$InputFormFunctions1(A))$InputFormFunctions1(A),sk)
