)abbrev category AXIOM Axiom
++ Properties and axioms for symbolic rewrite rules
Axiom(): Category == Type with
    axioms: () -> List Equation InputForm

)abbrev category COMAX CommutativeAxiom
++ Commutative
CommutativeAxiom(): Category == Axiom

)abbrev category DISAX DistributiveAxiom
++ Distributive
DistributiveAxiom(): Category == Axiom

)abbrev category ASSAX AssociativeAxiom
++ Associative
AssociativeAxiom(): Category == Axiom

)abbrev category IDAX IdentityAxiom
++ Identities
IdentityAxiom(): Category == Axiom

)abbrev category CONAX ConstantsAxiom
++ Constants
ConstantsAxiom(): Category == Axiom

)abbrev category DBLAX DoublesAxiom
++ Doubling
DoublesAxiom(): Category == Axiom

)abbrev category SQAX SquaresAxiom
++ Squares
SquaresAxiom(): Category == Axiom

)abbrev category SYMCAT SymbolicCategory
SymbolicCategory(R : Join(Comparable,ConvertibleTo(InputForm))) : Category == Exports where
  F ==> Expression R
  Exports ==> Join(FunctionSpace R,ConvertibleTo(InputForm),CoercibleTo(OutputForm)) with
    axioms: () -> List Equation InputForm
    _+: (%,%) -> %
    _-: (%,%) -> %
    _-: % -> %
    _*: (%,%) -> %
    _*:(PositiveInteger,%) -> %
    _*:(NonNegativeInteger,%) -> %
    _/: (%,%) -> %
    _^: (%,%) -> %
    _^: (%,Integer) -> %
    nthRoot: (%, %) -> %
    nthRoot: (%, Integer) -> %
    if R has IntegralDomain then
      Ring
      AlgebraicallyClosedFunctionSpace R
      TranscendentalFunctionCategory
      CombinatorialOpsCategory
      LiouvillianFunctionCategory
      SpecialFunctionCategory
      coerce: Polynomial R -> %
      -- transformations
      expand: % -> %
    if % has FunctionSpace(Integer) then
      factor: % -> %
    if % has TranscendentalFunctionCategory and R has GcdDomain then
      simplify : % -> %
    -- coercions
    coerce: Pi -> %
    coerce: % -> F
    coerce: F -> %
    convert: Equation % -> Equation InputForm
    convert: Equation InputForm -> Equation %
    convert: InputForm -> %
    --
    equal?: Equation % -> Boolean
    --eq  : (%, %) -> Equation InputForm

)abbrev domain SYMB Symbolic
++ Unevaluated mathematical expressions
++ Author: Bill Page
++ Date Created: 15 Novermber 2016
++ Description:
++ Expressions involving symbolic functions that remain unevaluated and are
++ displayed as entered. Evaluation is delayed until an operation is performed
++ which requires a canonical form such as testing for equality or
++ simplification. The domain depends directly internally on the Expression
++ domain for evaluation of expressions.
++ Keywords: expression, evaluation, operator, function.
Symbolic(R : Join(Comparable,ConvertibleTo(InputForm)), AxiomList : Type) : Exports == Implementation where
  F ==> Expression R
  K   ==> Kernel %
  KF  ==> Kernel F
  SMP  ==> SparseMultivariatePolynomial(R, K)
  LIFT ==> PolynomialCategoryLifting(IndexedExponents(KF),KF,R,SparseMultivariatePolynomial(R,KF),SMP)
  --AF  ==> AlgebraicFunction(R, F)
  --EF  ==> ElementaryFunction(R, F)
  CF  ==> CombinatorialFunction(R, F)
  --LF  ==> LiouvillianFunction(R, F)
  --AN  ==> AlgebraicNumber
  --KAN ==> Kernel AN
  --ESD ==> ExpressionSpace_&(F)
  --FSD ==> FunctionSpace_&(F, R)
  SIN ==> %
  LES ==> List Equation SIN
  Maybe(S) ==> Union(S,"failed")

  Exports ==> SymbolicCategory(R)

  Implementation ==> add
    Rep := InputForm

    if AxiomList has Axiom then
      -- It might be nice if this was displayed like Symbolic(Integer,None)
      -- but that would be recursive and require bootstrap mode.
      axioms() == axioms()$AxiomList
    else
      axioms() == []
    belong? op == true
    -- use equality from Expression(R)
    (x:% = y:%):Boolean == coerce(x)@F = coerce(y)@F
    hash(x:%):SingleInteger == hash(x pretend Rep)$InputForm
    -- term ordering:
    -- breadth first < integer (numeric) < float (numeric) < symbol (lexical)
    smaller?(x:%,y:%):Boolean ==
      --output("smaller? ",paren [x::OutputForm,y::OutputForm])$OutputPackage
      null? y => false
      list? y => null? x or list? x and (smaller?(car x,car y) or not smaller?(car y,car x) and smaller?(cdr x,cdr y))
      integer? y => null? x or list? x or integer? x and integer x < integer y
      float? y => null? x or list? x or symbol? x or float? x and float x < float y
      symbol? y => null? x or list? x or integer? x or float? x or symbol? x and symbol x < symbol y
      false
    equal?(eq:Equation %):Boolean == not smaller?(lhs eq,rhs eq) and not smaller?(lhs eq,rhs eq)
    --
    eval(x:%,k:Kernel(%),s:%):% == subst(x,[k],[s])
    eval(x:%):% == coerce eval(coerce x)$F
    eval(x:%,a:%,b:%):% == coerce eval(coerce(x)@F, coerce(a)@F, coerce(b)@F)
    eval(x:%,e:Equation %):% == eval(x,lhs e,rhs e)
    --
    subst(x:%,e:Equation %):% == SUBST(rhs(e) pretend Rep,lhs(e) pretend Rep,x pretend Rep)$Lisp
    subst(x:%,ks:List Kernel %, vs:List %) ==
      if #ks > 1 then return subst(subst(x,equation(first(ks)::%,first(vs))),rest ks, rest vs)
      else return subst(x,equation(first(ks)::%,first(vs)))
    subst(x:%, es:List Equation %):% ==
      if #es > 1 then return subst(subst(x, first es),rest es)
      else subst(x, first es)
    --
    -- need to handel subscripted Symbol
    retractIfCan(x:%):Union(Kernel %,"failed") ==
      if atom? x and symbol? x then return kernel symbol x
      if list? x and symbol? car x then
        if list? cdr x then
          s := symbol car x
          if not member?(s,['_+,'_-,'_*,'_/])$List(Symbol) then
            k:Kernel(%) := kernel(operator(s)$CommonOperators,
              destruct cdr x, #cdr(x)::NonNegativeInteger)
            return k
      return "failed"
    retract(x:%):Symbol ==
      k:Union(Kernel %,"failed"):=retractIfCan(x)
      if k case "failed" then
        error "not a kernel"
      else
        return name k
    --
    isPlus1(x:%):Union(List %,"failed") ==
      list? x and symbol? car x and symbol car x = '_+ => destruct cdr x
      "failed"
    isTimes1(x:%):Union(List %,"failed") ==
      list? x and symbol? car x and symbol car x = '_* => destruct cdr x
      "failed"
    if R has IntegralDomain then
      0:% == coerce(0$F)
      1:% == coerce(1$F)
      one? x  == (x = 1)$Rep
      zero? x == (x = 0)$Rep
      k2(k:KF):SMP ==
        ak:List % := [coerce x for x in argument k]
        return coerce kernel(operator k,ak,position k)$K
      r2(r:R):SMP == coerce r
      numer(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        map(k2,r2, numer(coerce x)$F)$LIFT
      denom(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        map(k2,r2, denom(coerce x)$F)$LIFT
      (x:SMP / y:SMP):% == coerce(x) / coerce(y)
      isPlus(x:%):Union(List %,"failed") == isPlus1(x)

      factorials(x:%):%           == coerce factorials(coerce x)$CF
      factorials(x:%, n:Symbol):% == coerce factorials(coerce x, n)$CF
      expand(x:%):% ==
        n := isPlus numerator(coerce x)$F
        if n case List F then
          d:% := denominator(x)
          if d=1 then return reduce("+",[coerce(s) for s in n])
          return reduce("+",[coerce(s)/d for s in n])
        else
          return x
      coerce(x:SMP):% == convert(x)@InputForm
      coerce(x:Polynomial R):% == convert(x)@InputForm
      coerce(x:Fraction R):% == convert(x)@InputForm
      if R has RetractableTo Integer or R has RetractableTo Fraction Integer then
        retractIfCan(x:%):Union(Fraction Integer,"failed") ==
          r:Union(R,"failed"):=retractIfCan(x)
          if R has RetractableTo Fraction Integer then
            return retractIfCan(r::R)@Union(Fraction Integer,"failed")
          if R has RetractableTo Integer then
            r2:Union(Integer,"failed"):=retractIfCan(r::R)
            if r2 case Integer then return r2::Integer::Fraction Integer
          return "failed"

    if F has FunctionSpace(Integer) then
      factor(x:%):% ==
        (factor(numer(coerce x)$F)::OutputForm pretend InputForm /
          factor(denom(coerce x)$F)::OutputForm pretend InputForm)$InputForm

    coerce(x:Pi):% == convert(x)@InputForm
    coerce(x:Symbol):% == convert(x)@InputForm
    coerce(k:Kernel %):% == coerce name(k)

    coerceOutputForm(x:Rep):OutputForm ==
      if null? x then return empty()$OutputForm
      if atom? x then return (x pretend OutputForm)
      if list? x and symbol? car x then
        s := symbol car x
        if s='float then
          return interpret(x)$InputFormFunctions1(Float)::OutputForm
        if s='factorial then
          if list? car(cdr x) then
            return postfix(outputForm '_!, paren coerceOutputForm car cdr x)
          else
            return postfix(outputForm '_!, coerceOutputForm car cdr x)
        if s='sum or s='summation then
            return sum(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='product then
            return prod(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='binomial then
            return binomial(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='sqrt then
            return root coerceOutputForm car cdr x
        if s='nthRoot then
            return root(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='exp and car(cdr x)=1 then return outputForm '%e
        if member?(s,['_+,'_-,'_*,'_/,'_^])$List(Symbol) and #cdr(x)>1 then
          if AxiomList has AssociativeAxiom then
            return infix(outputForm s, [coerceOutputForm(i) for i in destruct cdr x])
          else
            return paren infix(outputForm s, [coerceOutputForm(i) for i in destruct cdr x])
        else
          if list? car(cdr x) or s ~= '_- then
            return prefix(outputForm s,
              [coerceOutputForm(i) for i in destruct cdr x])
          else
            return hconcat([outputForm s, hspace(1), coerceOutputForm car cdr x])
      return hconcat(message("what is:")$OutputForm,x pretend OutputForm)
    coerce(x:%):OutputForm == coerceOutputForm(x pretend Rep)

    -- +0 is a hack to avoid premature conversion
    hack(x:%):Rep == x -- binary(convert('_+),[x::Rep,0::Rep])

    coerce(x:%):F ==
      v:List Symbol := variables x
      if #v = 0 then return interpret(hack x)$InputFormFunctions1(F)
      -- we need to substitute variables with unknown modes
      s:List Symbol := [new()$Symbol for vi in v]
      ks:List Equation % := [equation(coerce(vi)$%, coerce(si)$%) for vi in v for si in s]
      sk:List Equation F := [equation(coerce(si)$F, coerce(vi)$F) for vi in v for si in s]
      return subst(interpret(hack subst(x,ks))$InputFormFunctions1(F),sk)
    coerce(x:F):% == convert(x)@InputForm
    coerce(x:R):% == convert(x)@InputForm
    convert(x:%):InputForm == x pretend Rep
    convert(x:InputForm):% ==interpret(hack x)$InputFormFunctions1(%)
    --
    factorial(x:%):%          == convert([convert('factorial)@InputForm,x::Rep])
    binomial(n:%, m:%):%      == binary(convert('binomial),[n::Rep,m::Rep])$InputForm
    permutation(n:%, m:%):%   == binary(convert('permutation),[n::Rep,m::Rep])$InputForm
    --
    sum(x : %, n : Symbol):%           == binary(convert('sum),[x::Rep,convert(n)@InputForm])$InputForm
    sum(x : %, s : SegmentBinding %):% == binary(convert('sum),[x::Rep,convert(s)@InputForm])$InputForm
    summation(x : %, n : Symbol):%           == binary(convert('summation),[x::Rep,convert(n)@InputForm])$InputForm
    summation(x : %, s : SegmentBinding %):% == binary(convert('summation),[x::Rep,convert(s)@InputForm])$InputForm
    product(x : %, n : Symbol):%             == binary(convert('product),[x::Rep,convert(n)@InputForm])$InputForm
    product(x : %, s : SegmentBinding %):%   == binary(convert('product),[x::Rep,convert(s)@InputForm])$InputForm

    -- We don't want the InputForm +0 and *1 auto-simplification but we
    -- might be doing our own simplifications.
    (x:% ^ y:%):% == binary(convert('_^),[x::Rep,y::Rep])$InputForm
    (x:% ^ y:PositiveInteger):% == expt(x, y)$RepeatedSquaring(%)
    (x:% ^ y:NonNegativeInteger):% ==
      if y = 0 then x^0
      else x ^ y::PositiveInteger
    (x:% ^ y:Integer):% ==
      if y < 0 then 1/(x ^ (-y)::PositiveInteger)
      else x ^ y::NonNegativeInteger
    (x:% ^ y:Fraction Integer):% == nthRoot(x,denom(y))^numer(y)
    --
    plus: (%,%) -> %
    times(x:%,y:%):% ==
      --output("times: ",paren [coerce(x)@OutputForm,coerce(y)@OutputForm])$OutputPackage
      if AxiomList has IdentityAxiom then
        if x=1 then return y
        if y=1 then return x
      if AxiomList has CommutativeAxiom then
        if smaller?(y,x) then return times(y,x)
        if AxiomList has AssociativeAxiom then
          if (t:=isTimes1(x)) case List % then
            if smaller?(y,t(2)) then return times(times(t(1),y),t(2))
      if AxiomList has Associative then
        if (t:=isTimes1(y)) case List % then
          return times(times(x,t(1)),t(2))
      if AxiomList has SquaresAxiom then
        if R has SemiGroup then
          if equal? equation(x,y) then return x^2
      if AxiomList has ConstantsAxiom then
        if R has IntegralDomain then
          if (r1:=retractIfCan(x)@Union(R,"failed")) case R then
            if (r2:=retractIfCan(y)@Union(R,"failed")) case R then
              return coerce(r1*r2)
      if AxiomList has DistributiveAxiom then
        if (t:=isPlus1(x)) case List % then
          return plus(times(t(1),y),times(t(2),y))
        if (t:=isPlus1(y)) case List % then
          return plus(times(x,t(1)),times(x,t(2)))
      return binary(convert('_*),[x::Rep,y::Rep])$InputForm
    (x:% * y:%):% == times(x,y)
    (x:PositiveInteger * y:%):% == double(x,y)$RepeatedDoubling(%)
    (x:NonNegativeInteger * y:%):% ==
      if x=0 then 0*y
      else x::PositiveInteger * y
    (x:Integer * y:%):% ==
      if x < 0 then
        (-x)::PositiveInteger * y
      else
        x::NonNegativeInteger * y
    --
    plus(x:%,y:%):% ==
      --output("plus: ",paren [coerce(x)@OutputForm,coerce(y)@OutputForm])$OutputPackage
      if AxiomList has IdentityAxiom then
        if x=0 then return y
        if y=0 then return x
      if AxiomList has CommutativeAxiom then
        if smaller?(y,x) then return plus(y,x)
        if AxiomList has AssociativeAxiom then
          if (t:=isPlus1(x)) case List % then
            if smaller?(y,t(2)) then return plus(plus(t(1),y),t(2))
      if AxiomList has AssociativeAxiom then
        if (t:=isPlus1(y)) case List % then
          return plus(plus(x,t(1)),t(2))
      if AxiomList has DoublesAxiom then
        if R has AbelianSemiGroup then
          if equal? equation(x,y) then return times(2::%,x)
          if AxiomList has AssociativeAxiom then
            if (t:=isPlus1(x)) case List % then
              if equal? equation(t(2),y) then return plus(t(1),times(2::%,y))
      if AxiomList has ConstantsAxiom then
        if R has IntegralDomain then
          if (r1:=retractIfCan(x)@Union(R,"failed")) case R then
            if (r2:=retractIfCan(y)@Union(R,"failed")) case R then
              return coerce(r1+r2)
      return binary(convert('_+),[x::Rep,y::Rep])$InputForm
    (x:% + y:%):% == plus(x,y)

    (x:% - y:%):% == binary(convert('_-),[x::Rep,y::Rep])$InputForm

    (x:% / y:%):% == binary(convert('_/),[x::Rep,y::Rep])$InputForm


    _-(x:%):% == convert([convert('_-)@InputForm,x::Rep])

    --elt(f:BasicOperator,x:%):% == convert([convert(name f)@InputForm,x::Rep])
    elt(f:BasicOperator,x:List %):% ==
      convert(concat(convert(name f)@InputForm,[i::Rep for i in x]))

    -- Elementary Functions
    acos(x:%):% == convert([convert('acos)@InputForm,x::Rep])
    acosh(x:%):% == convert([convert('acosh)@InputForm,x::Rep])
    acot(x:%):% == convert([convert('acot)@InputForm,x::Rep])
    acoth(x:%):% == convert([convert('acoth)@InputForm,x::Rep])
    acsc(x:%):% == convert([convert('acsc)@InputForm,x::Rep])
    acsch(x:%):% == convert([convert('acsch)@InputForm,x::Rep])
    asec(x:%):% == convert([convert('asec)@InputForm,x::Rep])
    asech(x:%):% == convert([convert('asech)@InputForm,x::Rep])
    asin(x:%):% == convert([convert('asin)@InputForm,x::Rep])
    asinh(x:%):% == convert([convert('asinh)@InputForm,x::Rep])
    atan(x:%):% == convert([convert('atan)@InputForm,x::Rep])
    atanh(x:%):% == convert([convert('atanh)@InputForm,x::Rep])
    cos(x:%):% == convert([convert('cos)@InputForm,x::Rep])
    cosh(x:%):% == convert([convert('cosh)@InputForm,x::Rep])
    cot(x:%):% == convert([convert('cot)@InputForm,x::Rep])
    coth(x:%):% == convert([convert('coth)@InputForm,x::Rep])
    csc(x:%):% == convert([convert('csc)@InputForm,x::Rep])
    csch(x:%):% == convert([convert('csch)@InputForm,x::Rep])
    exp(x:%):% == convert([convert('exp)@InputForm,x::Rep])
    log(x:%):% == convert([convert('log)@InputForm,x::Rep])
    nthRoot(x:%, n:Integer) == binary(convert('nthRoot),[x::Rep,n::Rep])$InputForm
    nthRoot(x:%, n:%) == binary(convert('nthRoot),[x::Rep,n::Rep])$InputForm
    --pi():% == convert([convert('pi)@InputForm])
    sec(x:%):% == convert([convert('sec)@InputForm,x::Rep])
    sech(x:%):% == convert([convert('sech)@InputForm,x::Rep])
    sin(x:%):% == convert([convert('sin)@InputForm,x::Rep])
    sinh(x:%):% == convert([convert('sinh)@InputForm,x::Rep])
    sqrt(x:%):% == convert([convert('sqrt)@InputForm,x::Rep])
    tan(x:%):% == convert([convert('tan)@InputForm,x::Rep])
    tanh(x:%):% == convert([convert('tanh)@InputForm,x::Rep])
    --
    retract(x:%):R == retract(coerce x)$F

    variables1(x:Rep):Set Symbol ==
      if null? x then return empty()
      if atom? x and symbol? x then return set [symbol x]
      if list? x and symbol? car x then
        if list? cdr x then
          return reduce("union", [variables1(i) for i in destruct cdr x])
        else
          return variables1 car cdr x
      return empty()
    variables(x:%):List Symbol == members variables1(x pretend Rep)

    -- still need to handle non symbols and scripted symbols
    kernels1(x:Rep):Set Kernel % ==
      if null? x then return empty()
      if atom? x and symbol? x then return set [kernel symbol x]
      if list? x and symbol? car x then
          if list? cdr x then
            s := symbol car x
            if member?(s,['_+,'_-,'_*,'_/])$List(Symbol) then
              r:Set Kernel % := reduce("union",
                [kernels1(i) for i in destruct cdr x])
              return r
            else
              k:Kernel(%) := kernel(operator(s)$CommonOperators,
                destruct cdr x, #cdr(x)::NonNegativeInteger)
              return set [k]
          else
            return kernels1 car cdr x
      return empty()
    kernels(x:%):List Kernel % == members kernels1(x pretend Rep)

    if F has TranscendentalFunctionCategory and R has GcdDomain then
      simplify(x:%):% ==
        coerce(simplify(coerce x)$TranscendentalManipulations(R,F))
    convert(eq:Equation %): Equation InputForm == equation(convert lhs eq, convert rhs eq)
    convert(eq:Equation InputForm): Equation % == equation(convert lhs eq, convert rhs eq)

)abbrev domain COM Commutative
Commutative():CommutativeAxiom == add
    import Symbolic(Integer,None)
    x := coerce 'x
    y := coerce 'y
    axioms() ==
      [ convert equation (x+y, y+x),
        convert equation (x*y, y*x) ]

)abbrev domain DIS Distributive
Distributive():DistributiveAxiom == add
  import Symbolic(Integer,None)
  x := coerce 'x
  y := coerce 'y
  z := coerce 'z
  axioms() ==
    [ convert equation (x*(y+z), (x*y)+(x*z)) ]

)abbrev domain ASS Associative
Associative():AssociativeAxiom == add
  import Symbolic(Integer,None)
  x := coerce 'x
  y := coerce 'y
  z := coerce 'z
  axioms() ==
    [ convert equation ((x+y)+z, x+(y+z)),
      convert equation ((x*y)*z, (x*(y*z))) ]

)abbrev domain ID Identities
Identities():IdentityAxiom == add
  import Symbolic(Integer,None)
  x := coerce 'x
  axioms() ==
    [ convert equation (x+0, x), convert equation (0+x, x),
      convert equation (x*1, x), convert equation (1*x, x) ]

)abbrev domain CON Constants
Constants():ConstantsAxiom == add
  import Symbolic(Integer,None)
  x := coerce 'x
  y := coerce 'y
  retractIfCan:BasicOperator := operator 'retractIfCan
  axioms() ==
    [ convert equation (retractIfCan(x)+retractIfCan(y), retractIfCan(x+y)) ]

)abbrev domain DBL Doubles
Doubles():DoublesAxiom == add
  import Symbolic(Integer,None)
  x := coerce 'x
  axioms() == [ convert equation (x+x, 2*x) ]

)abbrev domain SQ Squares
Squares():SquaresAxiom == add
  import Symbolic(Integer,None)
  x := coerce 'x
  axioms() == [ convert equation (x*x, x^2) ]

)abbrev domain AA /\
++ Adding rules
(A:Axiom /\ B:Axiom):Axiom with
    if A has CommutativeAxiom then CommutativeAxiom
    if B has CommutativeAxiom then CommutativeAxiom
    if A has DistributiveAxiom then DistributiveAxiom
    if B has DistributiveAxiom then DistributiveAxiom
    if A has AssociativeAxiom then AssociativeAxiom
    if B has AssociativeAxiom then AssociativeAxiom
    if A has IdentityAxiom then IdentityAxiom
    if B has IdentityAxiom then IdentityAxiom
    if A has ConstantsAxiom then ConstantsAxiom
    if B has ConstantsAxiom then ConstantsAxiom
    if A has DoublesAxiom then DoublesAxiom
    if B has DoublesAxiom then DoublesAxiom
    if A has SquaresAxiom then SquaresAxiom
    if B has SquaresAxiom then SquaresAxiom
  == add
    axioms() == concat(axioms()$A,axioms()$B)

)abbrev domain SEXPR SymbolicExpression
SymbolicExpression(R : Join(Comparable,ConvertibleTo(InputForm))) : SymbolicCategory(R)
  == Symbolic(R,Identities/\Commutative/\Associative/\Distributive/\Constants/\Doubles/\Squares)

)abbrev package SYMPKG1 SymbolicFunctions1
SymbolicFunctions1(R: Join(Comparable,ConvertibleTo InputForm), A:SymbolicCategory R,
  S: Join(Comparable,ConvertibleTo InputForm), B:SymbolicCategory S): with
    convert: B -> A
  == add
    -- +0 is a hack to avoid premature conversion
    hack(x:B):InputForm == binary(convert('_+),[convert x,0::InputForm])
    convert(x:B):A ==
      v:List Symbol := variables(x)
      if #v = 0 then return interpret(hack x)$InputFormFunctions1(A)
      -- we need to substitute variables with unknown modes
      s:List Symbol := [new()$Symbol for vi in v]
      ks:List Equation B := [equation(coerce(vi)$B, coerce(si)$B) for vi in v for si in s]
      sk:List Equation A := [equation(coerce(si)$A, coerce(vi)$A) for vi in v for si in s]
      return subst(interpret(hack subst(x,ks))$InputFormFunctions1(A),sk)
